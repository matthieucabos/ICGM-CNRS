%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Origin\_Server}
\date{Mar 29, 2022}
\release{2.1}
\author{CABOS Matthieu}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
\sphinxstylestrong{Author} \sphinxstyleemphasis{CABOS Matthieu}

\sphinxAtStartPar
\sphinxstylestrong{Date}  \sphinxstyleemphasis{2021/2022}

\sphinxAtStartPar
\sphinxstylestrong{Organization} \sphinxstyleemphasis{ICGM\sphinxhyphen{}CNRS}


\bigskip\hrule\bigskip


\sphinxAtStartPar
These Scripts have been written to manage properly an Origin Server (See \sphinxhref{https://ritme.com/software/origin/}{Origin})

\sphinxAtStartPar
It is adapted to the Origin ssh platform

\sphinxAtStartPar
(reading and treating \sphinxstylestrong{opt/Linux\_FLEXnet\_Server\_ver\_11.16.5.1/Licenses} and \sphinxstylestrong{/usr/local/flexlm/orglabdebug.log} wich are the Licence File and the Tokens Log file)

\sphinxAtStartPar
These scripts need a ssh session access into the origin server (with form origin.domain.fr)

\sphinxAtStartPar
These main scripts have been written to automate the DHCP Informations retrievment and Origin Server essentials informations.

\sphinxAtStartPar
The main project is made of the following files :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get\_Origin\_Info}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Origin\_API}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_tokens}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_log\_v2}

\end{itemize}

\sphinxAtStartPar
The others file concern two pre\sphinxhyphen{}versions of the project. Each of them is associated to its API:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Origin\_Users\_parallelisation\_v2}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Origin\_Users\_parallelisation\_v2 associated API}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get\_User\_Info\_From\_IP\_v2}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get\_User\_Info\_From\_IP\_v2 associated API}

\end{itemize}

\sphinxstepscope


\chapter{Get\_Origin\_Info\_v2.1.sh}
\label{\detokenize{Get_Origin_Info_v2.1:get-origin-info-v2-1-sh}}\label{\detokenize{Get_Origin_Info_v2.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Get\PYGZus{}Origin\PYGZus{}Info\PYGZus{}v2.1.sh
\end{sphinxVerbatim}

\sphinxAtStartPar
This is the finale version of the project. It give us the same informations as the Get\_Origin\_Info python files in less than 1 second.
It use a subshell by connected user to treat a large amount of users without a loss of time.

\sphinxAtStartPar
The algorithm used is similar as the python files, in fact, the optimisation is ruled by the tftp request ssh remote command (line 28).
The same output will be used to get almost all the needed informations as :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Username}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ip address}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cisco Switch Name}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Vlan Identifier}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mac address}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Socket Identifier (with form Gix/y/z)}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Connexion\_time (in minuts)}

\end{itemize}

\sphinxAtStartPar
The last information (description of the outlet, with form N1A01\sphinxhyphen{}01) is extracted from a last cisco ssh remote command defined line 43.
The differents informations are extracted by a regular expression filtering defined by :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Username} : \sphinxstyleemphasis{{[}A\sphinxhyphen{}Za\sphinxhyphen{}z0\sphinxhyphen{}9\_\sphinxhyphen{}êïù{]}+@{[}A\sphinxhyphen{}Za\sphinxhyphen{}z0\sphinxhyphen{}9\_\sphinxhyphen{}{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ip address} : \sphinxstyleemphasis{({[}0\sphinxhyphen{}9{]}+\textbackslash{}.)\{3\}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cisco Switch Name} : \sphinxstyleemphasis{balard\sphinxhyphen{}{[}0\sphinxhyphen{}9{]}{[}A\sphinxhyphen{}Z{]}\textbackslash{}\sphinxhyphen{}{[}0\sphinxhyphen{}9{]}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Vlan Identifier} : \sphinxstyleemphasis{\textbackslash{}s{[}0\sphinxhyphen{}9{]}\{3\}\textbackslash{}s}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mac address} : \sphinxstyleemphasis{({[}0\sphinxhyphen{}9a\sphinxhyphen{}f{]}\{4\}\textbackslash{}.)\{2\}{[}0\sphinxhyphen{}9a\sphinxhyphen{}f{]}\{4\}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Socket Identifier} : \sphinxstyleemphasis{Gi({[}0\sphinxhyphen{}9{]}\textbackslash{}/)\{2\}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Connexion\_time} : by the following equation \sphinxstyleemphasis{M1\sphinxhyphen{}M2 + (H1\sphinxhyphen{}H2)*60} where :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{H1} : \sphinxstyleemphasis{The Now date command extracted time Hours field}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{H2} : \sphinxstyleemphasis{The Start Connexion Time Hours field}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{M1} : \sphinxstyleemphasis{The Now date command extracted time Minuts field}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{M2} : \sphinxstyleemphasis{The Start Connexion Time Minuts field}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Description} : \sphinxstyleemphasis{{[}NRJPASEP{]}+{[}0\sphinxhyphen{}9A\sphinxhyphen{}Z.{]}+\textbackslash{}\sphinxhyphen{}{[}0\sphinxhyphen{}9{]}+}

\end{itemize}

\sphinxAtStartPar
The main algorithm is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the user:ip association} from the results of the Treat\_log\_v2.1.sh logfile analizer script

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the ip adress} : The ip address is extracted from the Treat\_log\_v2.1.sh script by applying the corresponding regular expression to its output

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Use the ip adress to request the tftp server} : Send a request to the tftp server as a ssh session with remote command as argument : grep \$ip /var/lib/tftpboot/snoop/where \$ip contains the previous result

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Filter the cisco name by regular expression pattern} : The Cisco name is extracted from the tftp response by applying the corresponding regular expression

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Filter the Vlan identifier by regular expression pattern} : The Vlan identifier is extracted from the tftp response by applying the corresponding regular expression

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Filter the MAC adress by regular expression pattern} : The MAC address is extracted from the tftp response by applying the corresponding regular expression

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Filter the Socket name by regular expression pattern} : The Socket name is extracted from the tftp response by applying the corresponding regular expression

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get origin name} : From the splitted current item (separator is ‘:’)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the time informations associated to the user} : Get the corresponding line in the time\_list by filteering with previous name result

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the time “now”} : Get the absolute ‘now’ time from the command \sphinxstylestrong{\textasciigrave{}date +\%H\textasciigrave{}”:”\textasciigrave{}date +\%M\textasciigrave{}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the “now” hours field} : Split the First field of the Now time from separator \sphinxstylestrong{‘:’}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the “start” hours field} : Split the First field of the Start time from separator \sphinxstylestrong{‘:’}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the “now” minuts field} : Split the Second field of the Now time from separator \sphinxstylestrong{‘:’}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the “start” minuts field} : Split the Second field of the Start time from separator \sphinxstylestrong{‘:’}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Check if user is connected} : Brownse the response of the origin ssh remote command : \sphinxstylestrong{/opt/Linux\_FLEXnet\_Server\_ver\_11.16.5.1/lmutil  lmstat \sphinxhyphen{}a \sphinxhyphen{}c /opt/Linux\_FLEXnet\_Server\_ver\_11.16.5.1/Licenses/Origin\_20jetons.lic | grep “\textasciicircum{}.*origin.srv\sphinxhyphen{}prive.icgm.fr/27000.*”}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Use cisco and socket fields to connect the switch and get description field} : From the command \sphinxstylestrong{ssh \$\{Cisco\textasciicircum{}\} “show interfaces description | i “\$Socket” | tail \sphinxhyphen{}1”}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\$\{Cisco\textasciicircum{}\}} is the Cisco name with upper first letter

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\$Socket} is the socket number with form \sphinxstylestrong{Gix/y/z}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Filter the Description by regular expression pattern} : Apply the Description regular expression from the previou result

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Compute connexion time} : From H1, H2, M1, M2 with the equation \sphinxstylestrong{M1\sphinxhyphen{}M2 + (H1\sphinxhyphen{}H2)*60}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Results display} : Sort the differents informations fields into a string

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Put in on screen} : Put them on screen OR write it in file

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{} Author : CABOS Matthieu}
\PYG{c+c1}{\PYGZsh{} Date : 24/01/2022}

\PYG{n+nv}{Content}\PYG{o}{=}\PYG{l+s+sb}{`}./Treat\PYGZus{}log\PYGZus{}v2.1.sh\PYG{l+s+sb}{`}                                                                             \PYG{c+c1}{\PYGZsh{} Get the user:ip association}
\PYG{n+nv}{IP\PYGZus{}list}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{field}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}

\PYG{n+nv}{time\PYGZus{}list}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{index}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{Connected}\PYG{o}{=}\PYG{l+s+sb}{`}ssh origin.srv\PYGZhy{}prive.icgm.fr \PYG{l+s+s1}{\PYGZsq{}/opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/lmutil  lmstat \PYGZhy{}a \PYGZhy{}c /opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/Licenses/Origin\PYGZus{}20jetons.lic | grep \PYGZdq{}\PYGZca{}.*origin\PYGZbs{}.srv\PYGZhy{}prive\PYGZbs{}.icgm\PYGZbs{}.fr/27000.*\PYGZdq{}\PYGZsq{}}\PYG{l+s+sb}{`}

\PYG{n+nv}{old\PYGZus{}IFS}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IFS}
\PYG{n+nv}{IFS}\PYG{o}{=}\PYG{l+s+s1}{\PYGZdl{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{for} item \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}Connected}
\PYG{k}{do}
        \PYG{n+nv}{name}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}item} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K\PYGZca{}\PYGZbs{}s+[A\PYGZhy{}Za\PYGZhy{}zïîëêù\PYGZbs{}\PYGZus{}\PYGZbs{}\PYGZhy{}]+\PYGZdq{}}\PYG{l+s+sb}{`}
        \PYG{n+nv}{time\PYGZus{}list}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}time\PYGZus{}list}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}name}\PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}item} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K[0\PYGZhy{}9]+\PYGZbs{}:[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}\PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}n\PYGZdq{}}
\PYG{k}{done}

\PYG{k}{function} Treat\PYG{o}{(}\PYG{o}{)}\PYG{o}{\PYGZob{}}
        \PYG{n+nv}{item}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}1}
        \PYG{n+nv}{ip}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}item} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K([0\PYGZhy{}9]+\PYGZbs{}.)\PYGZob{}3\PYGZcb{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}                                                     \PYG{c+c1}{\PYGZsh{} Get the ip adress}
        \PYG{n+nv}{Info}\PYG{o}{=}\PYG{l+s+sb}{`}ssh tftp grep \PYG{n+nv}{\PYGZdl{}ip} /var/lib/tftpboot/snoop/\PYG{l+s+se}{\PYGZbs{}*}\PYG{l+s+sb}{`}                                                    \PYG{c+c1}{\PYGZsh{} Use the ip adress to request the tftp server}
        \PYG{n+nv}{Cisco}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}Info} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}Kbalard\PYGZhy{}[0\PYGZhy{}9][A\PYGZhy{}Z]\PYGZbs{}\PYGZhy{}[0\PYGZhy{}9]\PYGZdq{}}\PYG{l+s+sb}{`}                                             \PYG{c+c1}{\PYGZsh{} Filter the cisco name by regular expression pattern}
        \PYG{n+nv}{Vlan}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}Info} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K\PYGZbs{}s[0\PYGZhy{}9]\PYGZob{}3\PYGZcb{}\PYGZbs{}s\PYGZdq{}}\PYG{l+s+sb}{`}                                                                                              \PYG{c+c1}{\PYGZsh{} Filter the Vlan identifier by regular expression pattern}
        \PYG{n+nv}{Mac}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}Info} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K([0\PYGZhy{}9a\PYGZhy{}f]\PYGZob{}4\PYGZcb{}\PYGZbs{}.)\PYGZob{}2\PYGZcb{}[0\PYGZhy{}9a\PYGZhy{}f]\PYGZob{}4\PYGZcb{}\PYGZdq{}}\PYG{l+s+sb}{`}                                          \PYG{c+c1}{\PYGZsh{} Filter the MAC adress by regular expression pattern}
        \PYG{n+nv}{Socket}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}Info} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}KGi([0\PYGZhy{}9]\PYGZbs{}/)\PYGZob{}2\PYGZcb{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}                                                \PYG{c+c1}{\PYGZsh{} Filter the Socket name by regular expression pattern}
        \PYG{n+nv}{name}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}item} \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}@\PYGZdq{}} \PYGZhy{}f1\PYG{l+s+sb}{`}                                                                     \PYG{c+c1}{\PYGZsh{} Get origin name}
        \PYG{n+nv}{time}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYGZhy{}e \PYG{n+nv}{\PYGZdl{}time\PYGZus{}list} \PYG{p}{|} grep \PYG{n+nv}{\PYGZdl{}name}\PYG{l+s+sb}{`}                                                                 \PYG{c+c1}{\PYGZsh{} Get the time informations associazted to the user}
        \PYG{n+nv}{now}\PYG{o}{=}\PYG{l+s+sb}{`}date +\PYGZpc{}H\PYG{l+s+sb}{`}\PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}}\PYG{l+s+sb}{`}date +\PYGZpc{}M\PYG{l+s+sb}{`}                                                                            \PYG{c+c1}{\PYGZsh{} Get the time \PYGZdq{}now\PYGZdq{}}
        \PYG{n+nv}{H1}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}now} \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}} \PYGZhy{}f1\PYG{l+s+sb}{`}                                                                        \PYG{c+c1}{\PYGZsh{} Get the \PYGZdq{}now\PYGZdq{} hours field}
        \PYG{n+nv}{H2}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}time} \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}} \PYGZhy{}f2\PYG{l+s+sb}{`}                                                                       \PYG{c+c1}{\PYGZsh{} Get the \PYGZdq{}start\PYGZdq{} hours field}
        \PYG{n+nv}{M1}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}now} \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}} \PYGZhy{}f2\PYG{l+s+sb}{`}                                                                        \PYG{c+c1}{\PYGZsh{} Get the \PYGZdq{}now\PYGZdq{} minuts field}
        \PYG{n+nv}{M2}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}time} \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}} \PYGZhy{}f3\PYG{l+s+sb}{`}                                                                       \PYG{c+c1}{\PYGZsh{} Get the \PYGZdq{}start\PYGZdq{} minuts field}

        \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Connected}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=}\PYG{o}{=} *\PYG{n+nv}{\PYGZdl{}name}* \PYG{o}{]}\PYG{o}{]}                                                                       \PYG{c+c1}{\PYGZsh{} Check if user is connected}
        \PYG{k}{then}
                \PYG{n+nv}{Description}\PYG{o}{=}\PYG{l+s+sb}{`}ssh \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{Cisco}\PYG{p}{\PYGZca{}}\PYG{l+s+si}{\PYGZcb{}} \PYG{l+s+s2}{\PYGZdq{}show interfaces description | i \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Socket}\PYG{l+s+s2}{\PYGZdq{} | tail \PYGZhy{}1\PYGZdq{}}\PYG{l+s+sb}{`}                  \PYG{c+c1}{\PYGZsh{} Use cisco and socket fields to connect the switch and get description field}
                \PYG{n+nv}{Description}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}Description} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K[NRJPASEP]+[0\PYGZhy{}9A\PYGZhy{}Z.]+\PYGZbs{}\PYGZhy{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}                       \PYG{c+c1}{\PYGZsh{} Filter the Description by regular expression pattern}
                \PYG{n+nv}{Connexion\PYGZus{}time}\PYG{o}{=}\PYG{k}{\PYGZdl{}((}M1\PYGZhy{}M2 \PYG{o}{+} \PYG{o}{(}H1\PYGZhy{}H2\PYG{o}{)}\PYG{o}{*}\PYG{l+m}{60}\PYG{k}{))}                                                             \PYG{c+c1}{\PYGZsh{} Compute connexion time}
                \PYG{n+nv}{field}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}item}\PYG{l+s+s2}{\PYGZdq{} | \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Cisco}\PYG{l+s+s2}{\PYGZdq{} | \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Vlan}\PYG{l+s+s2}{\PYGZdq{} | \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Mac}\PYG{l+s+s2}{\PYGZdq{} | \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Socket}\PYG{l+s+s2}{\PYGZdq{} | \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Description}\PYG{l+s+s2}{\PYGZdq{} | \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Connexion\PYGZus{}time}\PYG{l+s+s2}{\PYGZdq{} min\PYGZdq{}}   \PYG{c+c1}{\PYGZsh{} Results display}
                \PYG{c+c1}{\PYGZsh{} date \PYGZgt{}\PYGZgt{} Origin\PYGZus{}Connexion\PYGZus{}Time}
                \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}field} \PYGZgt{}\PYGZgt{} Origin\PYGZus{}Connexion\PYGZus{}Time                                                               \PYG{c+c1}{\PYGZsh{} Put in on screen}
        \PYG{k}{fi}
\PYG{o}{\PYGZcb{}}
\PYG{n+nv}{IFS}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}old\PYGZus{}IFS}
\PYG{k}{for} item \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}Content}
\PYG{k}{do}
        Treat \PYG{n+nv}{\PYGZdl{}item} \PYG{p}{\PYGZam{}}
\PYG{k}{done}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Get\_Origin\_Info.py}
\label{\detokenize{Get_Origin_Info:get-origin-info-py}}\label{\detokenize{Get_Origin_Info::doc}}
\newpage
\section{Version 2.2}
\label{\detokenize{Get_Origin_Info:version-2-2}}
\sphinxAtStartPar
The update concern the used versions of Origin\_API (the version 2 will be used here) and the Treat\_log script (the version 2.1 will be used here).
Once the newest extensions loaded, the results are treated in real time and the execution time is about 20 seconds.

\sphinxAtStartPar
To use as an history manager, please to launch directly on the remote server (the one wich can access the origin server) with the correct ssh anthorizations keys from the command :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nohup python3 ./Get\PYGZus{}Origin\PYGZus{}Info\PYGZus{}v2.2.py
\end{sphinxVerbatim}

\sphinxAtStartPar
The results will be stored twice :
\begin{itemize}
\item {} 
\sphinxAtStartPar
One version of the history is stored in the local folder

\item {} 
\sphinxAtStartPar
The other one is stored into the origin server root

\end{itemize}

\sphinxAtStartPar
To stop the nohup process, please to respect the path to follow :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Identify the process PID using the command \sphinxstylestrong{ps \sphinxhyphen{}aux | grep nohup}

\item {} 
\sphinxAtStartPar
Kill the process as root with the command \sphinxstylestrong{sudo kill \sphinxhyphen{}9 \textless{}PID\textgreater{}}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{re}
\PYG{k+kn}{from} \PYG{n+nn}{Origin\PYGZus{}API\PYGZus{}v2} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{\PYGZus{}\PYGZus{}author\PYGZus{}\PYGZus{}}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CABOS Matthieu}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{\PYGZus{}\PYGZus{}date\PYGZus{}\PYGZus{}}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{12/01/2022}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Copy the logwatch file in the current directory}

\PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}/logwatch .}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Users}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./Treat\PYGZus{}log\PYGZus{}v2.1.sh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Defining Regular Expressions}

\PYG{n}{regex\PYGZus{}user}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.*}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{regex\PYGZus{}ip}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{user\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{ip\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} getting User:ip association informations since the output of the Treat\PYGZus{}log\PYGZus{}v2.sh filtered by regular expressions.}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Users}\PYG{p}{)}
\PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}user}\PYG{p}{,} \PYG{n}{Users}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{user\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}ip}\PYG{p}{,} \PYG{n}{Users}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ip\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{user\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{ip\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{n}{user\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{=}\PYG{n}{get\PYGZus{}Dict}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Manage the display of the database}

\PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{Sheet}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adresse ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hostname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adresse mac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Socket}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Vlan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Switch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Description}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Connexion Time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Rajouter le start time, la date et l\PYGZsq{}heure ?}
\PYG{n}{Connection\PYGZus{}Time}\PYG{o}{=}\PYG{n}{Get\PYGZus{}Connexion\PYGZus{}Time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Connected\PYGZus{}content}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Connection\PYGZus{}Time}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Updating the content to write in history}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{hostname}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{is\PYGZus{}connected}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{,}\PYG{n}{Connected\PYGZus{}content}\PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} Récupérer uniquement les utilisateurs connéctés}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{)}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{Snoop\PYGZus{}Dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{Connection\PYGZus{}Time}\PYG{p}{[}\PYG{n}{hostname}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Connection time not avaible for user }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{Sheet}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{)}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Print at screen as trivial verification}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Sheet}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Writing content into the origin history file and update the origin server}

\PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Origin\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Sheet}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{item} \PYG{o}{!=} \PYG{p}{[}\PYG{p}{]} \PYG{p}{:}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ | }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp ./Origin\PYGZus{}history }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{Version 2.1}
\label{\detokenize{Get_Origin_Info:version-2-1}}
\sphinxAtStartPar
The most efficient version using the Origin\_API extension.

\sphinxAtStartPar
It write the orgin activities history containing all the DHCP extracted informations in concordance with the tftp boot server (listing only \sphinxstylestrong{real} connected users).

\sphinxAtStartPar
In fact, you have to use it into a similar structure as following :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Origin
├── Get\PYGZus{}Origin\PYGZus{}Info\PYGZus{}v2.1.py
├── Origin\PYGZus{}API.py
├── Treat\PYGZus{}log\PYGZus{}v2.sh
└── Treat\PYGZus{}tokens.sh
\end{sphinxVerbatim}

\sphinxAtStartPar
These actions need an efficient log file since the Origin server orglabdebug.log file.

\sphinxAtStartPar
I use a logwatch intermediate file with allocated token inserted into the token log file.

\sphinxAtStartPar
It is ruled by a shell automated script containing the following instructions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
date \PYGZgt{}\PYGZgt{} ./logwatch
ss \PYGZhy{}n \PYGZhy{}t \PYG{p}{|} grep \PYG{l+m}{60213} \PYGZgt{}\PYGZgt{} ./logwatch
tail \PYGZhy{}n \PYG{l+m}{1} /usr/local/flexlm/orglabdebug.log \PYGZgt{}\PYGZgt{} ./logwatch
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxstylestrong{60213} is the communication port number of the Origin application.

\sphinxAtStartPar
This shell script is lauched periodically with the following linux commands.
It must be launched with the \sphinxstylestrong{nohup} linux command to make it write properly and permanently the logwatch file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
inotifywait \PYGZhy{}q \PYGZhy{}m \PYGZhy{}e modify /usr/local/flexlm/orglabdebug.log\PYG{p}{|}
\PYG{k}{while} \PYG{n+nb}{read} \PYGZhy{}r filename event\PYG{p}{;} \PYG{k}{do}
 ./Script.sh
\PYG{k}{done}
\end{sphinxVerbatim}

\sphinxAtStartPar
With this way of work, the orglabdebug.log file and the logwatch file will never be altered.

\sphinxAtStartPar
This script require differents ssh authorizations keys as :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cisco Switch connected to the network} \sphinxstyleemphasis{(All the Balard\sphinxhyphen{}XY\sphinxhyphen{}Z switch access)}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{tftp.srv\sphinxhyphen{}prive.icgm.fr} \sphinxstyleemphasis{(All the daily connected repertored users)}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{origin.srv\sphinxhyphen{}prive.icgm.fr} \sphinxstyleemphasis{(The main origin server)}

\end{itemize}

\sphinxAtStartPar
With access to these ssh passerel you will be able to retrieve all the needed informations to identify and keep tracability on your Origin server.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{re}
\PYG{k+kn}{from} \PYG{n+nn}{Origin\PYGZus{}API} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{\PYGZus{}\PYGZus{}author\PYGZus{}\PYGZus{}}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CABOS Matthieu}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{\PYGZus{}\PYGZus{}date\PYGZus{}\PYGZus{}}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{12/01/2022}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Copy the logwatch file in the current directory}

\PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}/logwatch .}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Users}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./Treat\PYGZus{}log\PYGZus{}v2.sh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Defining Regular Expressions}

\PYG{n}{regex\PYGZus{}user}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.*}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{regex\PYGZus{}ip}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{user\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{ip\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} getting User:ip association informations since the output of the Treat\PYGZus{}log\PYGZus{}v2.sh filtered by regular expressions.}

\PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}user}\PYG{p}{,} \PYG{n}{Users}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{user\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}ip}\PYG{p}{,} \PYG{n}{Users}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ip\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{user\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{ip\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{n}{user\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{=}\PYG{n}{get\PYGZus{}Dict}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Manage the display of the database}

\PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{Sheet}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adresse ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hostname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adresse mac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Socket}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Vlan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Switch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Description}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Connexion Time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Rajouter le start time, la date et l\PYGZsq{}heure ?}
\PYG{n}{Connection\PYGZus{}Time}\PYG{o}{=}\PYG{n}{build\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Updating the content to write in history}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{hostname}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{if} \PYG{n}{is\PYGZus{}connected}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{,}\PYG{n}{Connected\PYGZus{}content}\PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} Récupérer uniquement les utilisateurs connéctés}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{)}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{Snoop\PYGZus{}Dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{Connection\PYGZus{}Time}\PYG{p}{[}\PYG{n}{hostname}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Connection time not avaible for user }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{Sheet}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{)}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Print at screen as trivial verification}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Sheet}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Writing content into the origin history file and update the origin server}

\PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Origin\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Sheet}\PYG{p}{:}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ | }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp ./Origin\PYGZus{}history }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{Version 2}
\label{\detokenize{Get_Origin_Info:version-2}}
\sphinxAtStartPar
That version is similar to the version 1. There is no display in this one but the Origin History file is properly written.
The version 2 is treating the \sphinxstylestrong{full daily logwatch content} and should be used at the end of a day for exemple or to verify the results of the version 2.1.

\sphinxAtStartPar
It give us the \sphinxstylestrong{same informations than the version 2.1} but it will display into the Origin history file \sphinxstylestrong{all the activities} on the \sphinxstylestrong{origin server}.

\sphinxAtStartPar
It must be consider as a \sphinxstylestrong{pre\sphinxhyphen{}version of version 2.1} and should be used also as a \sphinxstylestrong{log file analyzer}.

\sphinxAtStartPar
\sphinxstylestrong{Susbtitute the differents date} variables (as \sphinxstyleemphasis{day, month, year, etc}) \sphinxstylestrong{with a specific date} will treat the logwatch file \sphinxstylestrong{since this specific date}.

\sphinxAtStartPar
This script will be used as a logwatch analizer instead of a real time analizer like the version 2.1 and it could be really interesting with \sphinxstylestrong{network management} and \sphinxstylestrong{administration tool}.

\sphinxAtStartPar
Please to use with the correct following syntax :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 Get\PYGZus{}Origin\PYGZus{}Info\PYGZus{}v2.py
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{re}
\PYG{k+kn}{from} \PYG{n+nn}{Get\PYGZus{}tftp\PYGZus{}infos} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{Get\PYGZus{}Connexion\PYGZus{}Time} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}/logwatch .}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Users}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./Treat\PYGZus{}log\PYGZus{}v2.sh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{regex\PYGZus{}user}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.*}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{regex\PYGZus{}ip}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{user\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{ip\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}user}\PYG{p}{,} \PYG{n}{Users}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{user\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}ip}\PYG{p}{,} \PYG{n}{Users}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ip\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{user\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{ip\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{n}{user\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{=}\PYG{n}{get\PYGZus{}Dict}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{Sheet}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adresse ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hostname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adresse mac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Socket}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Vlan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Switch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Description}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Connexion Time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{Connection\PYGZus{}Time}\PYG{o}{=}\PYG{n}{build\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{user\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{hostname}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{)}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{Snoop\PYGZus{}Dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{try}\PYG{p}{:}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{Connection\PYGZus{}Time}\PYG{p}{[}\PYG{n}{hostname}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ min}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{except}\PYG{p}{:}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Connection time not avaible for user }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{hostname}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Sheet}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{)}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Origin\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Sheet}\PYG{p}{:}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ | }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp ./Origin\PYGZus{}history }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{Version 1}
\label{\detokenize{Get_Origin_Info:version-1}}
\sphinxAtStartPar
This script is the full optimised and parallelized code version of the Origin Users Informations Getter.
It allow us to get since an Origin server and the tftp server repertoring connected people the full informations content since the log description to the connection time.

\sphinxAtStartPar
It uses :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_log\_v2.sh} file to get an immediate association between user ID and their IP.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_tokens.sh} script to get a tokens manager into your Python Code

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get\_Connexion\_Time.py} Library to get the connexion time elapsed by user.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get\_tftp\_infos.py} Library to treat and manage a Tftp content from the server

\end{itemize}

\sphinxAtStartPar
It must be used into the equivalent environment :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
.
├── dhcpd\PYGZhy{}501.conf
├── dhcpd\PYGZhy{}510.conf
├── dhcpd\PYGZhy{}511.conf
├── dhcpd\PYGZhy{}512.conf
├── dhcpd\PYGZhy{}513.conf
├── dhcpd\PYGZhy{}514.conf
├── dhcpd\PYGZhy{}515.conf
├── dhcpd\PYGZhy{}516.conf
├── dhcpd\PYGZhy{}518.conf
├── dhcpd\PYGZhy{}519.conf
├── dhcpd\PYGZhy{}524.conf
├── dhcpd\PYGZhy{}525.conf
├── dhcpd\PYGZhy{}526.conf
├── dhcpd\PYGZhy{}528.conf
├── dhcpd\PYGZhy{}529.conf
├── dhcpd\PYGZhy{}530.conf
├── dhcpd.conf
└── Origin\PYGZus{}Manager
    ├── Get\PYGZus{}Connexion\PYGZus{}Time.py
    ├── Get\PYGZus{}Origin\PYGZus{}Info.py
    ├── Get\PYGZus{}tftp\PYGZus{}infos.py
    ├── Treat\PYGZus{}log\PYGZus{}v2.sh
    └── Treat\PYGZus{}tokens.sh
\end{sphinxVerbatim}

\sphinxAtStartPar
This Script use the already written associated script.
The ssh sessions connections have been parallelized to make the script faster than ever.

\sphinxAtStartPar
The algorithm follow these steps in order :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the logwatch file}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat the Treat\_log\_v2.sh output} since regular expressions to get the correct user2ip list

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the Snoop dictionnary} since the tftp server of connected people (cf  \sphinxhref{https://en.wikipedia.org/wiki/DHCP\_snooping}{DHCP Snooping} )

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the connection time} since the \sphinxstyleemphasis{Get\_Connexion\_Time} library

\end{itemize}

\sphinxAtStartPar
Please to use with the correct following syntax :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 Get\PYGZus{}Origin\PYGZus{}Info.py
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Origin\_API}
\label{\detokenize{Origin_API:origin-api}}\label{\detokenize{Origin_API::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Author} \sphinxstyleemphasis{CABOS Matthieu}

\sphinxAtStartPar
\sphinxstylestrong{Date}  \sphinxstyleemphasis{2021/2022}

\sphinxAtStartPar
\sphinxstylestrong{Organization} \sphinxstyleemphasis{ICGM\sphinxhyphen{}CNRS}

\sphinxstepscope

\newpage
\section{ssh\_session}
\label{\detokenize{OA/ssh_session:ssh-session}}\label{\detokenize{OA/ssh_session::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{command}\PYG{p}{,}\PYG{n}{return\PYGZus{}dict}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/ssh_session:definition}}
\sphinxAtStartPar
Configure and execute a SSH session with remote commands (not an option.)

\sphinxAtStartPar
It is an automatic authentified ssh session, using the environment parameters as :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Home absolute way}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{user from environment variables}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ssh keyfile from the given absolute way}

\end{itemize}

\sphinxAtStartPar
The results will be stored into the return dict dictionnary using the Python Multithreading functions.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{cisco}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Str}
&
\sphinxAtStartPar
The name of the Cisco Switch to connect
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{command}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Str List}
&
\sphinxAtStartPar
The String command list to send to the cisco switch
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{return\_dict}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary storing commands output by Cisco name
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/ssh_session:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The dictionnary linking to a Cisco switch name as a key its commands list output from console.


\subsection{Source}
\label{\detokenize{OA/ssh_session:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{command}\PYG{p}{,}\PYG{n}{return\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{Output}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/cisco}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco\PYGZus{}ios}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{n}{IPSwitchs}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{command}\PYG{p}{:}
                \PYG{n}{Output}\PYG{o}{+}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{return\PYGZus{}dict}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{o}{=}\PYG{n}{Output}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Treat\_out}
\label{\detokenize{OA/Treat_out:treat-out}}\label{\detokenize{OA/Treat_out::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}out}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/Treat_out:definition}}
\sphinxAtStartPar
Treating shell command ouptut since the tftp Boot informations reading.

\sphinxAtStartPar
To do so, this function is ruled by regular expression as :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{regex\_ip} : \sphinxstylestrong{({[}0\sphinxhyphen{}9{]}+\textbackslash{}.)\{3\}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{regex\_mac} : \sphinxstylestrong{({[}a\sphinxhyphen{}zA\sphinxhyphen{}Z0\sphinxhyphen{}9{]}\{4\}\textbackslash{}.)\{2\}{[}a\sphinxhyphen{}zA\sphinxhyphen{}Z0\sphinxhyphen{}9{]}\{4\}}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{regex\_socket} : \sphinxstylestrong{Gi({[}0\sphinxhyphen{}9{]}+\textbackslash{}/)\{2\}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{regex\_vlan} : \sphinxstylestrong{\textbackslash{}s{[}0\sphinxhyphen{}9{]}\{3\}\textbackslash{}s}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{regex\_switch} : \sphinxstylestrong{Balard\sphinxhyphen{}{[}0\sphinxhyphen{}9A\sphinxhyphen{}Z{]}+\textbackslash{}\sphinxhyphen{}{[}0\sphinxhyphen{}9{]}+}

\end{itemize}

\sphinxAtStartPar
This method treat a commands list output from a ssh session with a cisco switch.
It read and treat in multiline mode every met values from regular expression and store these informations into the returned dictionnary.
The returned dictionnary is builded with the ip as key and following informations as values :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{MAC address}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cisco GigabitEthernet socket (with form Gix/y/z)}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The Vlan identifier as Integer}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The switch name as String}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{output}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Str}
&
\sphinxAtStartPar
The raw commands list output from the ssh session with a cisco switch
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/Treat_out:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The builded dictionnary linking to an ip as key the Cisco informations


\subsection{Source}
\label{\detokenize{OA/Treat_out:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}out}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{regex\PYGZus{}ip}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}mac}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([a\PYGZhy{}zA\PYGZhy{}Z0\PYGZhy{}9]}\PYG{l+s+si}{\PYGZob{}4\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{[a\PYGZhy{}zA\PYGZhy{}Z0\PYGZhy{}9]}\PYG{l+s+si}{\PYGZob{}4\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}socket}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gi([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{/)}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}vlan}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{s[0\PYGZhy{}9]}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{s}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}switch}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}[0\PYGZhy{}9A\PYGZhy{}Z]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZhy{}[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{n}{ip}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{mac}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{socket}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{vlans}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{switch}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{res}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}ip}\PYG{p}{,}\PYG{n}{output}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{ip}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}mac}\PYG{p}{,}\PYG{n}{output}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{mac}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}socket}\PYG{p}{,}\PYG{n}{output}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{socket}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}vlan}\PYG{p}{,}\PYG{n}{output}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{vlans}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}switch}\PYG{p}{,} \PYG{n}{output}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{switch}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{n}{mac}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{socket}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{vlans}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{switch}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Get\_Description}
\label{\detokenize{OA/Get_Description:get-description}}\label{\detokenize{OA/Get_Description::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Description}\PYG{p}{(}\PYG{n}{Snoop\PYGZus{}Dict}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/Get_Description:definition}}
\sphinxAtStartPar
Get the full plug name since the Snoop dictionnary present into the tftp server (into the \sphinxstyleemphasis{var/lib/tftpboot/snoop/} repertory).

\sphinxAtStartPar
Only the real connected users will be repertoried here since the snoop tftp boot repertory.
This methos has been partially coded with a parallel section to treat ssh connection faster.

\sphinxAtStartPar
This method is following this algorithm :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Building Cisco Instructions list} by Switch (stored into the \sphinxstyleemphasis{tmp} variable)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Manage the multiprocessing section} of the code with the splitted Switch Dictionnary and the shared return dictionnary to store results of ssh sessions.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Launching the multiprocess list} with the correct method \sphinxstyleemphasis{ssh\_session} and associated builded Cisco instructions list.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Start and join the differents process} and rebuild the return dictionnary sorted by Cisco Switch name

\item {} 
\sphinxAtStartPar
The results of \sphinxstylestrong{the multiples ssh session give us the full outlet description name} (with form N1A01\sphinxhyphen{}01) by regular expression filtering

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Build the Description\_dictionnary} linking to a Cisco gigabitEthernet socket (Gix/y/z) as key its outlet exact description.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Snoop\_Dict}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dict}
&
\sphinxAtStartPar
The snoop dictionnary extracted from the tftp server
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/Get_Description:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The builded dictionnary associating to a cisco gigabit ethernet socket \sphinxstyleemphasis{(Gix/y/z)} its exact outlet description name as String.


\subsection{Source}
\label{\detokenize{OA/Get_Description:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Description}\PYG{p}{(}\PYG{n}{Snoop\PYGZus{}Dict}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{commands}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{command}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{term shell}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
                \PYG{k}{break}

        \PYG{c+c1}{\PYGZsh{} Building Cisco Instructions list by Switch (stored into the *tmp* variable)}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{==} \PYG{n}{tmp}\PYG{p}{:}
                        \PYG{n}{command}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{show interfaces description | i }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ | tail \PYGZhy{}1}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{commands}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}\PYG{o}{=}\PYG{n}{command}
                        \PYG{n}{command}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{term shell}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
                        \PYG{n}{command}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{show interfaces description | i }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ | tail \PYGZhy{}1}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{n}{commands}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}\PYG{o}{=}\PYG{n}{command}
        \PYG{n}{output}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{return\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{\PYGZsh{} Manage the multiprocessing section of the code with the splitted Switch Dictionnary and the shared return dictionnary to store results of ssh sessions.}

        \PYG{n}{List\PYGZus{}Dic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{div}\PYG{o}{=}\PYG{l+m+mi}{14}
        \PYG{n}{List\PYGZus{}Dic}\PYG{o}{=}\PYG{n}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}
        \PYG{n}{manager}\PYG{o}{=}\PYG{n}{multiprocessing}\PYG{o}{.}\PYG{n}{Manager}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{return\PYGZus{}dict}\PYG{o}{=}\PYG{n}{manager}\PYG{o}{.}\PYG{n}{dict}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{Process\PYGZus{}List}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

        \PYG{c+c1}{\PYGZsh{} Launching the multiprocess list with the correct method *ssh\PYGZus{}session* and associated builded Cisco instructions list.}

        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{List\PYGZus{}Dic}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{cisco}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{List\PYGZus{}Dic}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{Process\PYGZus{}List}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{p}{,}\PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{commands}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{p}{,}\PYG{n}{return\PYGZus{}dict}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ is not avaible as key.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Start and join the differents process and rebuild the return dictionnary sorted by Cisco Switch name}

        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{List\PYGZus{}Dic}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{Process\PYGZus{}List}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ is not avaible as key.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{List\PYGZus{}Dic}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{Process\PYGZus{}List}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ is not avaible as key.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} The results of the multiples ssh session give us the full outlet description name (with form N1A01\PYGZhy{}01) by regular expression filtering}

        \PYG{n}{regex\PYGZus{}socket}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{compile}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gi([0\PYGZhy{}9]+}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{/)}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s2}{[0\PYGZhy{}9]+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{regex\PYGZus{}desc}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[NRJPASEP]+[0\PYGZhy{}9A\PYGZhy{}Z.]+}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{\PYGZhy{}[0\PYGZhy{}9]+}\PYG{l+s+s2}{\PYGZdq{}}

        \PYG{n}{socket\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{descr\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{Description\PYGZus{}dictionnary}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{\PYGZsh{} Build the Description\PYGZus{}dictionnary linking to a Cisco gigabitEthernet socket (Gix/y/z) as key its outlet exact description.}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{return\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{v}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{match}\PYG{o}{=}\PYG{n}{regex\PYGZus{}socket}\PYG{o}{.}\PYG{n}{match}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
                        \PYG{n}{match2}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{findall}\PYG{p}{(}\PYG{n}{regex\PYGZus{}desc}\PYG{p}{,}\PYG{n}{item}\PYG{p}{)}
                        \PYG{k}{try}\PYG{p}{:}
                                \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{n}{match2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                        \PYG{k}{except}\PYG{p}{:}
                                \PYG{k}{pass}
                \PYG{n}{Description\PYGZus{}dictionnary}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{tmp\PYGZus{}dict}
                \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n}{Description\PYGZus{}dictionnary}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{cut\_dic}
\label{\detokenize{OA/cut_dic:cut-dic}}\label{\detokenize{OA/cut_dic::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/cut_dic:definition}}
\sphinxAtStartPar
Utilitary method to split properly and in adequation with the multiprocessing parameters the given dictionnary.

\sphinxAtStartPar
Split Dictionnary into div differents dictionnary.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IPSwitchs}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dict}
&
\sphinxAtStartPar
The shared dictionnary associating to a Cisco switch name its IP address.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{div}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Integer}
&
\sphinxAtStartPar
The number of slices to build from the given dictionnary
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/cut_dic:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{List}

\sphinxAtStartPar
A list of dictionnary containing the main dictionnary splitted into div differents sections.


\subsection{Source}
\label{\detokenize{OA/cut_dic:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{p}{)}\PYG{o}{/}\PYG{n}{div}\PYG{p}{)}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{IPSwitchs}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}
                \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{ind}\PYG{o}{==}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
                        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_Dict}
\label{\detokenize{OA/get_Dict:get-dict}}\label{\detokenize{OA/get_Dict::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Dict}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/get_Dict:definition}}
\sphinxAtStartPar
Get the main informations dictionnary repertoring these following field:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{IP address as key}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{MAC address}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cisco Socket}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Vlan Identifier}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cisco Switch name}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Outlet Description}

\end{itemize}

\sphinxAtStartPar
The five firsts informations are extracted from the tftp boot server to get exact real values from cisco switch.
The last one is extracted from Cisco switch multiple requests.


\subsection{Returns}
\label{\detokenize{OA/get_Dict:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The Snoop dictionnary repertoring all the needed network informations.


\subsection{Source}
\label{\detokenize{OA/get_Dict:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Dict}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{output}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{command}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{Description\PYGZus{}Dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{k}{for} \PYG{n}{cisco} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{name}\PYG{o}{=}\PYG{n}{cisco}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{n}{cisco}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
                \PYG{n}{command}\PYG{o}{+}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sed \PYGZhy{}e }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s/\PYGZca{}/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}/}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ /var/lib/tftpboot/snoop/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{name}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/known\PYGZus{}hosts}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{output}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ssh }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@tftp.srv\PYGZhy{}prive.icgm.fr }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{=}\PYG{n}{Treat\PYGZus{}out}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}
        \PYG{n}{Description\PYGZus{}Dict}\PYG{o}{=}\PYG{n}{Get\PYGZus{}Description}\PYG{p}{(}\PYG{n}{Snoop\PYGZus{}Dict}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Snoop\PYGZus{}Dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{v}
                        \PYG{n}{description}\PYG{o}{=}\PYG{n}{Description\PYGZus{}Dict}\PYG{p}{[}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
                        \PYG{n}{Snoop\PYGZus{}Dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{description}\PYG{p}{]}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{k}{pass}

        \PYG{k}{return} \PYG{n}{Snoop\PYGZus{}Dict}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{reverse}
\label{\detokenize{OA/reverse:reverse}}\label{\detokenize{OA/reverse::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/reverse:definition}}
\sphinxAtStartPar
Perso reverse list function


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{line}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Str List}
&
\sphinxAtStartPar
A string line as list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/reverse:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Str List}

\sphinxAtStartPar
The reversed list


\subsection{Source}
\label{\detokenize{OA/reverse:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{!=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{pop\_double}
\label{\detokenize{OA/pop_double:pop-double}}\label{\detokenize{OA/pop_double::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{pop\PYGZus{}double}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/pop_double:definition}}
\sphinxAtStartPar
Pop double from list and build full hostname.

\sphinxAtStartPar
\sphinxstylestrong{To do so, we have to follow these instructions :}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Read the current line and store the doubled value as host}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Course te rest of list and extract the user name from it}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Rebuild the exact hostname and return it}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{line}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Str List}
&
\sphinxAtStartPar
A String line listed by words
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/pop_double:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String}

\sphinxAtStartPar
The exact hostname string with form \sphinxstylestrong{‘name@host’}


\subsection{Source}
\label{\detokenize{OA/pop_double:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{pop\PYGZus{}double}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{line}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{host}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{tmp}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{tmp}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{p}{:}
                        \PYG{n}{host}\PYG{o}{=}\PYG{n}{item}
                        \PYG{k}{while} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{tmp}\PYG{p}{:}
                                \PYG{n}{tmp}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{:}
                \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{name}\PYG{o}{!=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{host}\PYG{o}{!=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{return}\PYG{p}{(}\PYG{n}{name}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{host}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Get\_origin\_connected}
\label{\detokenize{OA/Get_origin_connected:get-origin-connected}}\label{\detokenize{OA/Get_origin_connected::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}origin\PYGZus{}connected}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/Get_origin_connected:definition}}
\sphinxAtStartPar
Manage a ssh session with the origin server to get the raw output of the Licence request to get connected users.
The used remote command is :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/lmutil  lmstat \PYGZhy{}a \PYGZhy{}c /opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/Licenses/Origin\PYGZus{}20jetons.lic \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}\PYGZca{}.*origin\PYGZbs{}.srv\PYGZhy{}prive\PYGZbs{}.icgm\PYGZbs{}.fr/27000.*\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Returns}
\label{\detokenize{OA/Get_origin_connected:returns}}
\sphinxAtStartPar
String
The output of the ssh remote command


\subsection{Source}
\label{\detokenize{OA/Get_origin_connected:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}origin\PYGZus{}connected}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/known\PYGZus{}hosts}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
        \PYG{n}{Output}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/lmutil  lmstat \PYGZhy{}a \PYGZhy{}c /opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/Licenses/Origin\PYGZus{}20jetons.lic | grep }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s1}{\PYGZca{}.*origin}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.srv\PYGZhy{}prive}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.icgm}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.fr/27000.*}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Output}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Get\_Connected}
\label{\detokenize{OA/Get_Connected:get-connected}}\label{\detokenize{OA/Get_Connected::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Connected}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/Get_Connected:definition}}
\sphinxAtStartPar
Getting the full connected users list in the origin server since the ssh remote commands.

\sphinxAtStartPar
The automated ssh session request the users list to the origin server Licence manager.

\sphinxAtStartPar
Once the list stored, it is treated by regular expression to extract the hostname list.

\sphinxAtStartPar
The used regular expression to extract hostname is : \sphinxstylestrong{\textbackslash{}s*{[}0\sphinxhyphen{}9A\sphinxhyphen{}Za\sphinxhyphen{}zïëîê\_\textbackslash{}s\sphinxhyphen{}{]}+}

\sphinxAtStartPar
This funtion use the \sphinxstylestrong{pop\_double} method.


\subsection{Returns}
\label{\detokenize{OA/Get_Connected:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Str List}

\sphinxAtStartPar
The full connected at Origin hostname list as Strings.


\subsection{Source}
\label{\detokenize{OA/Get_Connected:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Connected}\PYG{p}{(}\PYG{n}{Output}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{current}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{regex\PYGZus{}hostname}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{compile}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{s*[0\PYGZhy{}9A\PYGZhy{}Za\PYGZhy{}zïëîê\PYGZus{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{s\PYGZhy{}]+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} format the list with the correct form}

        \PYG{n}{Output}\PYG{o}{=}\PYG{p}{[}\PYG{n}{regex\PYGZus{}hostname}\PYG{o}{.}\PYG{n}{match}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{Output}\PYG{p}{]}

        \PYG{c+c1}{\PYGZsh{} Treating and extracting hostnames from the list}

        \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{host}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{Host\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{Output}\PYG{p}{:}
                \PYG{n}{current}\PYG{o}{=}\PYG{n}{reverse}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{Host\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{pop\PYGZus{}double}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Host\PYGZus{}list}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{is\_connected}
\label{\detokenize{OA/is_connected:is-connected}}\label{\detokenize{OA/is_connected::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}connected}\PYG{p}{(}\PYG{n}{user}\PYG{p}{,}\PYG{n}{Connected\PYGZus{}content}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/is_connected:definition}}
\sphinxAtStartPar
Check if the given user is in the connected list.
The connected list is given by the \sphinxstylestrong{Get\_Connected} method.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{user}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Str}
&
\sphinxAtStartPar
The user’s hostname to test
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Connected\_content}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Str List}
&
\sphinxAtStartPar
The Connected Hostnames list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/is_connected:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Boolean}

\sphinxAtStartPar
The Boolean value return \sphinxstylestrong{True} if present \sphinxstylestrong{False} else


\subsection{Source}
\label{\detokenize{OA/is_connected:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}connected}\PYG{p}{(}\PYG{n}{user}\PYG{p}{,}\PYG{n}{Connected\PYGZus{}content}\PYG{p}{)}\PYG{p}{:}

        \PYG{k}{return} \PYG{n}{user} \PYG{o+ow}{in} \PYG{n}{Connected\PYGZus{}content}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Compute\_elapsed\_time}
\label{\detokenize{OA/Compute_elapsed_time:compute-elapsed-time}}\label{\detokenize{OA/Compute_elapsed_time::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Compute\PYGZus{}elapsed\PYGZus{}time}\PYG{p}{(}\PYG{n}{Start\PYGZus{}dict}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/Compute_elapsed_time:definition}}
\sphinxAtStartPar
Compute the elapsed time connection dictionnary associating an user to his connexion time.
The function take one parameter : the dictionnary associating to an user a string start time extracted from the Origin Licence request.

\sphinxAtStartPar
Each user is brownsed by for loop to extract hour and minuts to make the timestamp.
The result is obtained making the timestamp difference between now and the start time, converted in minuts by dividing by 60.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Start\_dict}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary associating to an user his start time
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OA/Compute_elapsed_time:returns}}
\sphinxAtStartPar
Dictionnary
The dictionnary associating to an user his connexion time, computed by timestamp


\subsection{Source}
\label{\detokenize{OA/Compute_elapsed_time:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Compute\PYGZus{}elapsed\PYGZus{}time}\PYG{p}{(}\PYG{n}{Start\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Time\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{year}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date +}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{month}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date +}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{m}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{day}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date +}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{hour}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{minuts}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{seconds}\PYG{o}{=}\PYG{l+m+mi}{0}

        \PYG{n}{regex\PYGZus{}number}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Start\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}number}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{if} \PYG{n}{matchNum}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{:}
                                \PYG{n}{hour}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{elif} \PYG{n}{matchNum}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{p}{:}
                                \PYG{n}{minuts}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{else}\PYG{p}{:}
                                \PYG{k}{pass}
                \PYG{n}{date}\PYG{o}{=}\PYG{n}{dt}\PYG{o}{.}\PYG{n}{datetime}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{,}\PYG{n}{day}\PYG{p}{,}\PYG{n}{hour}\PYG{p}{,}\PYG{n}{minuts}\PYG{p}{,}\PYG{n}{seconds}\PYG{p}{)}
                \PYG{n}{Start\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{time}\PYG{o}{.}\PYG{n}{mktime}\PYG{p}{(}\PYG{n}{date}\PYG{o}{.}\PYG{n}{timetuple}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{now}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{Time\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{now}\PYG{o}{\PYGZhy{}}\PYG{n}{Start\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{Time\PYGZus{}dict}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Get\_Connexion\_Time}
\label{\detokenize{OA/Get_Connexion_Time:get-connexion-time}}\label{\detokenize{OA/Get_Connexion_Time::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Connexion\PYGZus{}Time}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OA/Get_Connexion_Time:definition}}
\sphinxAtStartPar
Main algorithm manager.
It is used to organize the algorithm rules :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Get the raw connected users from origin request.

\item {} 
\sphinxAtStartPar
Treating the Output via the Get\_Connected method to rebuild hostname with syntax \textless{}name\textgreater{}@\textless{}host\textgreater{}

\item {} 
\sphinxAtStartPar
Associate to each hostname its timestamp using following regular expression : \sphinxstylestrong{{[}0\sphinxhyphen{}9{]}+:{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
Compute the elapsed connexion time with the previous defined \sphinxstyleemphasis{Compute\_elapsed\_time} method.

\end{itemize}

\sphinxAtStartPar
It returns a dictionnary associating to each hostname its connexion time. The keys of the dictionnary should be used as list entry of connected people.


\subsection{Returns}
\label{\detokenize{OA/Get_Connexion_Time:returns}}
\sphinxAtStartPar
Dictionnary
The dictionnary associating to an user his connexion time, computed by timestamp


\subsection{Source}
\label{\detokenize{OA/Get_Connexion_Time:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Connexion\PYGZus{}Time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Output}\PYG{o}{=}\PYG{n}{Get\PYGZus{}origin\PYGZus{}connected}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Variable globale}
        \PYG{c+c1}{\PYGZsh{} Output=\PYGZdq{}    Raptor ZBOOK\PYGZhy{}3 ZBOOK\PYGZhy{}3 (v9.4) (origin.srv\PYGZhy{}prive.icgm.fr/27000 196), start Tue 1/11 07:54\PYGZbs{}n    Student DAMP\PYGZhy{}ST1 DAMP\PYGZhy{}ST1 (v9.4) (origin.srv\PYGZhy{}prive.icgm.fr/27000 196), start Tue 1/11 06:09\PYGZbs{}n    Romain DESKTOP\PYGZhy{}V7KRJB0 DESKTOP\PYGZhy{}V7KRJB0 (v9.4) (origin.srv\PYGZhy{}prive.icgm.fr/27000 1655), start Tue 1/11 05:18\PYGZbs{}n    jerome PC\PYGZhy{}Jerome PC\PYGZhy{}Jerome (v9.4) (origin.srv\PYGZhy{}prive.icgm.fr/27000 1165), start Tue 1/11 06:35\PYGZbs{}n    Rana C2m\PYGZhy{}PC C2m\PYGZhy{}PC (v9.4) (origin.srv\PYGZhy{}prive.icgm.fr/27000 262), start Tue 1/11 07:40\PYGZdq{}.split(\PYGZsq{}\PYGZbs{}n\PYGZsq{})}


        \PYG{n}{Output\PYGZus{}host}\PYG{o}{=}\PYG{n}{Get\PYGZus{}Connected}\PYG{p}{(}\PYG{n}{Output}\PYG{p}{)}
        \PYG{n}{regex\PYGZus{}start\PYGZus{}time}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}start\PYGZus{}time}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{Output}\PYG{p}{)}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}

        \PYG{n}{Start\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{Start\PYGZus{}dict}\PYG{p}{[}\PYG{n}{Output\PYGZus{}host}\PYG{p}{[}\PYG{n}{matchNum} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{return}\PYG{p}{(}\PYG{n}{Compute\PYGZus{}elapsed\PYGZus{}time}\PYG{p}{(}\PYG{n}{Start\PYGZus{}dict}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{Since version 2}
\label{\detokenize{Origin_API:since-version-2}}
\sphinxAtStartPar
This update contains following modificaton :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get connexion time rewritted}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Merged sections} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get Connexion Time Section}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get Connected Users Section}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
The two sections have been merged to optimise the execution time storing the Conneceted users and elapsed connection time in the same dictionnary using only one ssh authentified session.

\newpage
\section{Since version 1}
\label{\detokenize{Origin_API:since-version-1}}
\sphinxAtStartPar
This is the main methods repertory needed to manage properly an Origin Server.

\sphinxAtStartPar
It contains all the following functions :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{The Get Connexion Time Section} :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Init\_dict} : Initialize a dictionnary with defaults values

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{get\_max} : get the ma value from a list

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{get\_min} : Get the min value from a list

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{is\_connected} : Check if a specific user is connected

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{build\_dict} : Build the Commexion time elapsed dictionnary sort by user hostname

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{The Tftp Server Informations Getter Section} :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{ssh\_session} : Automate an authentified ssh session

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Treat\_out} : treat the Cisco output of an ssh session

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get\_Description} : Get the outlet description from a gigabithethernet socket

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{cut\_dic} : Split a dictionnary into slices to treat the parallel section

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{get\_Dict} : Get the tftp Snoop dictionnary repertoring all the needed informations

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{The Get Connected Users Section}:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{reverse} : Reverse the given list

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{pop\_double} : Treat the string list to retrieve hostname information

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get\_Connected} : Get the full hostname list from the connected users list

\end{itemize}

\end{description}

\end{itemize}

\sphinxAtStartPar
All these functions have been wrote for the ICGM laboratry network and must be adapted to another network (Ssh passerel identification informations, Cisco switchs name and addresses, etc…)

\sphinxAtStartPar
Please to load it directly into a Python interpreter from the command :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{Origin\PYGZus{}API} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Treat\_tokens}
\label{\detokenize{Treat_tokens:treat-tokens}}\label{\detokenize{Treat_tokens::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Treat\PYGZus{}tokens.sh \PYGZlt{}mode\PYGZgt{}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip


\newpage
\section{Principe}
\label{\detokenize{Treat_tokens:principe}}
\sphinxAtStartPar
To use the Treat\_tokens.sh script, you have to already instanced the \sphinxstylestrong{nohup} automated script to read and analyze the logwatch file.
The logwatch file must be contained into the same folder than the script.

\sphinxAtStartPar
The Treat\_tokens.sh script has been writtent to automate the Tokens Management from an Origin Server log file:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Each User take an \sphinxstylestrong{OUT} token to start a working session.

\item {} 
\sphinxAtStartPar
Each \sphinxstylestrong{OUT} token will be followed by an \sphinxstylestrong{IN} or \sphinxstylestrong{OUT} token, the last emitted \sphinxstylestrong{IN} or \sphinxstylestrong{OUT} token sign the closure of the connection

\item {} 
\sphinxAtStartPar
Each Token is associated to a \sphinxstylestrong{hostname} and a \sphinxstylestrong{timestamp}

\item {} 
\sphinxAtStartPar
Each connected \sphinxstylestrong{user is managed by tokens} during his session

\item {} 
\sphinxAtStartPar
Each tokens allocation and restitution is stored into the \sphinxstylestrong{orglabdebug.log} file

\end{itemize}

\sphinxAtStartPar
I am Dressing a \sphinxstyleemphasis{“Token map”} or \sphinxstyleemphasis{“Token array”} of the already distributed tokens.

\sphinxAtStartPar
To do so, see the followings methods :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the immediate Content of the daily logwatch file} \sphinxstyleemphasis{(generated with the same nohup script auto sheduled than the first Script)} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get day, month and year fields from the command date}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get the line number from the split must start with command} \sphinxstylestrong{grep \sphinxhyphen{}n}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get the number of line contained in the daily logwatch with the difference between the command} \sphinxstylestrong{wc \sphinxhyphen{}l} \sphinxstyleemphasis{result and the last one}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Cut the logwatch from the end with the command} \sphinxstylestrong{tail}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the raw Token list} associating User ID and the time field :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Brownse the daily logwatch content}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Filter by regular expressions line by line to get the following fields :}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Tokens (IN and OUT)}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Associated Hostnames (for both of them)}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Exact Date\sphinxhyphen{}Time field}

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Sorting tokens} by Type (IN or OUT):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Converting the Date\sphinxhyphen{}Time field to timestamp using the command} \sphinxstylestrong{date \sphinxhyphen{}d}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Switch the mode as parameter 1}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat the input} entries as a switch
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Differents mode filter differents results from the same list using regular expression}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Associate to each token an User ID} or Hostname (filtered by regular expressions):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Keeping in the same order the tokens list and the hostname list}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Associate to each token the correct Timestamp}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{From the timestamp conversion, print the correct timestamp associated to a token}

\end{itemize}

\end{itemize}

\newpage
\section{Usage}
\label{\detokenize{Treat_tokens:usage}}
\sphinxAtStartPar
Please to use with the correct syntax :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./Treat\PYGZus{}tokens.sh \PYGZlt{}mode\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
where mode balance between :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{1} : \sphinxstyleemphasis{Get the IN tokens}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{2} : \sphinxstyleemphasis{Get the OUT tokens}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{3} : \sphinxstyleemphasis{Get the IN Tokens Hostname}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{4} : \sphinxstyleemphasis{Get the OUT Toekns Hostname}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{5} : \sphinxstyleemphasis{Get the IN Tokens Timestamp Sorted List}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{6} : \sphinxstyleemphasis{Get the OUT Tokens Timestamp Sorted List}

\end{itemize}

\newpage
\section{Source}
\label{\detokenize{Treat_tokens:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{} Author : CABOS Matthieu}
\PYG{c+c1}{\PYGZsh{} Date : 22/12/2021}

Usage\PYG{o}{(}\PYG{o}{)}\PYG{o}{\PYGZob{}}

        \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}
\PYG{l+s+s2}{Welcome to the associated help of the tokens getter shell script.}

\PYG{l+s+s2}{Please to use with the correct syntax :}

\PYG{l+s+s2}{./Treat\PYGZus{}tokens.sh \PYGZlt{}mode\PYGZgt{}}

\PYG{l+s+s2}{where mode balance between :}

\PYG{l+s+s2}{* 1 : Get the IN tokens}
\PYG{l+s+s2}{* 2 : Get the OUT tokens}
\PYG{l+s+s2}{* 3 : Get the IN Tokens Hostname}
\PYG{l+s+s2}{* 4 : Get the OUT Toekns Hostname}
\PYG{l+s+s2}{* 5 : Get the IN Tokens Timestamp Sorted List}
\PYG{l+s+s2}{* 6 : Get the OUT Tokens Timestamp Sorted List}
\PYG{l+s+s2}{        \PYGZdq{}}
\PYG{o}{\PYGZcb{}}

\PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}\PYGZsh{}} \PYGZhy{}ne \PYG{l+m}{1} \PYG{o}{]} \PYG{o}{||} ! \PYG{o}{[}\PYG{o}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=}\PYGZti{} \PYG{o}{[}\PYG{l+m}{0}\PYGZhy{}9\PYG{o}{]} \PYG{o}{]}\PYG{o}{]}
\PYG{k}{then}
        \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}Nombre d\PYGZsq{}argument incorrect\PYGZdq{}}
        Usage
        \PYG{n+nb}{exit}
\PYG{k}{fi}

\PYG{n+nv}{day}\PYG{o}{=}\PYG{l+s+sb}{`}date \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYGZhy{}f1\PYG{l+s+sb}{`}
\PYG{n+nv}{month}\PYG{o}{=}\PYG{l+s+sb}{`}date \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYGZhy{}f2\PYG{l+s+sb}{`}
\PYG{n+nv}{num}\PYG{o}{=}\PYG{l+s+sb}{`}date \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYGZhy{}f3\PYG{l+s+sb}{`}
\PYG{n+nv}{today}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}day}\PYG{l+s+s2}{ }\PYG{n+nv}{\PYGZdl{}month}\PYG{l+s+s2}{ }\PYG{n+nv}{\PYGZdl{}num}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nv}{cut\PYGZus{}line}\PYG{o}{=}\PYG{l+s+sb}{`}cat logwatch \PYG{p}{|} grep \PYGZhy{}n \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}today}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{|} head \PYGZhy{}1 \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K\PYGZca{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}
\PYG{n+nv}{nb\PYGZus{}line}\PYG{o}{=}\PYG{l+s+sb}{`}wc \PYGZhy{}l logwatch \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K\PYGZca{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}
\PYG{n+nv}{read\PYGZus{}line}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{k}{\PYGZdl{}((}\PYG{n+nv}{\PYGZdl{}nb\PYGZus{}line}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{\PYGZdl{}cut\PYGZus{}line}\PYG{k}{))}\PYG{l+s+sb}{`}
\PYG{n+nv}{Content}\PYG{o}{=}\PYG{l+s+sb}{`}cat logwatch \PYG{p}{|} tail \PYGZhy{}\PYG{n+nv}{\PYGZdl{}read\PYGZus{}line}\PYG{l+s+sb}{`}
\PYG{n+nv}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{Token\PYGZus{}Liste}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{Token\PYGZus{}Liste\PYGZus{}OUT}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{count}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{User}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}

\PYG{k}{for} line \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}Content}
\PYG{k}{do}
        \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}line}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=}\PYGZti{} \PYG{l+s+se}{\PYGZbs{}@}.* \PYG{o}{]}\PYG{o}{]}
        \PYG{k}{then}
                \PYG{n+nv}{User}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line}\PYG{l+s+sb}{`}
        \PYG{k}{fi}
        \PYG{n+nv}{test}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K([0\PYGZhy{}9]+\PYGZbs{}:)\PYGZob{}2\PYGZcb{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}
        \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}Keep\PYGZus{}flag} \PYGZhy{}eq \PYG{l+m}{1} \PYG{o}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}count} \PYGZhy{}lt \PYG{l+m}{4} \PYG{o}{]}
        \PYG{k}{then}
                \PYG{n+nv}{tmp}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}tmp}\PYG{n+nv}{\PYGZdl{}line}
                \PYG{n+nv}{count}\PYG{o}{=}\PYG{k}{\PYGZdl{}((}count+1\PYG{k}{))}
                \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}Keep\PYGZus{}flag} \PYGZhy{}eq \PYG{l+m}{1} \PYG{o}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}count} \PYGZhy{}eq \PYG{l+m}{3} \PYG{o}{]}
                        \PYG{k}{then}
                                \PYG{n+nv}{tmp}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}tmp}\PYG{n+nv}{\PYGZdl{}User}
                                \PYG{n+nv}{count}\PYG{o}{=}\PYG{l+m}{4}
                \PYG{k}{fi}
        \PYG{k}{else}
                \PYG{n+nv}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{l+m}{0}
                \PYG{n+nv}{count}\PYG{o}{=}\PYG{l+m}{0}
        \PYG{k}{fi}
        \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}count} \PYGZhy{}eq \PYG{l+m}{2} \PYG{o}{]}
        \PYG{k}{then}
                \PYG{k}{if} ! \PYG{o}{(}\PYG{o}{[} \PYG{n+nv}{\PYGZdl{}line} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}IN:\PYGZdq{}} \PYG{o}{]} \PYG{o}{||} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}line} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}OUT:\PYGZdq{}} \PYG{o}{]}\PYG{o}{)}
                \PYG{k}{then}
                        \PYG{n+nv}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
                        \PYG{n+nv}{count}\PYG{o}{=}\PYG{l+m}{4}
                \PYG{k}{fi}
        \PYG{k}{fi}
        \PYG{k}{if} \PYG{o}{[} \PYGZhy{}n \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}test}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]}
        \PYG{k}{then}
                \PYG{n+nv}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{l+m}{1}
                \PYG{n+nv}{tmp}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}line}
        \PYG{k}{fi}
        \PYG{n+nv}{test}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}count} \PYGZhy{}eq \PYG{l+m}{4} \PYG{o}{]}
        \PYG{k}{then}
                \PYG{n+nv}{Token\PYGZus{}Liste}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}Token\PYGZus{}Liste}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}tmp}
        \PYG{k}{fi}
\PYG{k}{done}

\PYG{n+nv}{Month}\PYG{o}{=}\PYG{l+s+sb}{`}date +\PYGZpc{}m\PYG{l+s+sb}{`}
\PYG{n+nv}{Day}\PYG{o}{=}\PYG{l+s+sb}{`}date +\PYGZpc{}d\PYG{l+s+sb}{`}
\PYG{n+nv}{Year}\PYG{o}{=}\PYG{l+s+sb}{`}date +\PYGZpc{}Y\PYG{l+s+sb}{`}

\PYG{k}{for} line \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}Token\PYGZus{}Liste}
\PYG{k}{do}
        \PYG{n+nv}{Hour}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K\PYGZca{}[0\PYGZhy{}9]*\PYGZdq{}}\PYG{l+s+sb}{`}
        \PYG{n+nv}{Minuts}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K:[0\PYGZhy{}9]+:\PYGZdq{}} \PYG{p}{|} tr \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}:\PYGZsq{}}\PYG{l+s+sb}{`}
        \PYG{n+nv}{Seconds}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K:[0\PYGZhy{}9]+\PYGZbs{}(\PYGZdq{}} \PYG{p}{|} tr \PYGZhy{}d \PYG{l+s+s1}{\PYGZsq{}:(\PYGZsq{}}\PYG{l+s+sb}{`}
        \PYG{n+nv}{timestamp}\PYG{o}{=}\PYG{l+s+sb}{`}date \PYGZhy{}d \PYG{n+nv}{\PYGZdl{}Year}\PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Month}\PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Day}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Hour}\PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Minuts}\PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Seconds} +\PYGZpc{}s\PYG{l+s+sb}{`}
        \PYG{c+c1}{\PYGZsh{} echo \PYGZdl{}line}
        \PYG{k}{case} \PYG{n+nv}{\PYGZdl{}1} \PYG{k}{in}
                \PYG{l+m}{1} \PYG{o}{)}
                        \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}IN\PYGZdq{}} \PYG{p}{|} sed \PYG{l+s+s1}{\PYGZsq{}s/(orglab)/\PYGZhy{}/g\PYGZsq{}} \PYG{p}{|} sed \PYG{l+s+s1}{\PYGZsq{}s/\PYGZdq{}OriginPro\PYGZdq{}//g\PYGZsq{}}\PYG{p}{;}\PYG{p}{;}
                \PYG{l+m}{2} \PYG{o}{)}
                        \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}OUT\PYGZdq{}} \PYG{p}{|} sed \PYG{l+s+s1}{\PYGZsq{}s/(orglab)/\PYGZhy{}/g\PYGZsq{}} \PYG{p}{|} sed \PYG{l+s+s1}{\PYGZsq{}s/\PYGZdq{}OriginPro\PYGZdq{}//g\PYGZsq{}}\PYG{p}{;}\PYG{p}{;}
                \PYG{l+m}{3} \PYG{o}{)}
                        \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}IN\PYGZdq{}} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K[\PYGZbs{}sA\PYGZhy{}Za\PYGZhy{}z]*\PYGZbs{}@.*\PYGZdq{}}\PYG{p}{;}\PYG{p}{;}
                \PYG{l+m}{4} \PYG{o}{)}
                        \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}OUT\PYGZdq{}} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K[\PYGZbs{}sA\PYGZhy{}Za\PYGZhy{}z]*\PYGZbs{}@.*\PYGZdq{}}\PYG{p}{;}\PYG{p}{;}
                \PYG{l+m}{5} \PYG{o}{)}
                        \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYGZhy{}n \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}IN\PYGZdq{}}\PYG{l+s+sb}{`} \PYG{o}{]}\PYG{o}{]}
                        \PYG{k}{then}
                                \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}timestamp}
                        \PYG{k}{fi}\PYG{p}{;}\PYG{p}{;}
                \PYG{l+m}{6} \PYG{o}{)}
                        \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYGZhy{}n \PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}line} \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}OUT\PYGZdq{}}\PYG{l+s+sb}{`} \PYG{o}{]}\PYG{o}{]}
                        \PYG{k}{then}
                                \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}timestamp}
                        \PYG{k}{fi}\PYG{p}{;}\PYG{p}{;}
        \PYG{k}{esac}
\PYG{k}{done}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Treat\_log\_v2.1}
\label{\detokenize{Treat_log_v2.1:treat-log-v2-1}}\label{\detokenize{Treat_log_v2.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Treat\PYGZus{}log\PYGZus{}v2.1.sh \PYGZlt{}mode\PYGZgt{}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip


\newpage
\section{Principe}
\label{\detokenize{Treat_log_v2.1:principe}}
\sphinxAtStartPar
This script has been writtent to treat immediatly the logwatch file and associate to each \sphinxstylestrong{User ID} the correct \sphinxstylestrong{Ip address}.

\sphinxAtStartPar
To make it work, you have to write the logwatch file since the micro shell script and launcher.
(The orglabdebug.log file manager associating a date time to an event on the orglabdebug logfile)

\sphinxAtStartPar
It is ruled by automatic script :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
date \PYGZgt{}\PYGZgt{} ./logwatch
ss \PYGZhy{}n \PYGZhy{}t \PYG{p}{|} grep \PYG{l+m}{60213} \PYGZgt{}\PYGZgt{} ./logwatch
tail \PYGZhy{}n \PYG{l+m}{1} /usr/local/flexlm/orglabdebug.log \PYGZgt{}\PYGZgt{} ./logwatch
\end{sphinxVerbatim}

\sphinxAtStartPar
This script is lauched periodically with commands :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
inotifywait \PYGZhy{}q \PYGZhy{}m \PYGZhy{}e modify /usr/local/flexlm/orglabdebug.log\PYG{p}{|}
\PYG{k}{while} \PYG{n+nb}{read} \PYGZhy{}r filename event\PYG{p}{;} \PYG{k}{do}
 ./Script.sh
\PYG{k}{done}
\end{sphinxVerbatim}

\sphinxAtStartPar
This script is ruled by the following algorithm :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Get the file logwatch} from the orgin server using the command \sphinxstylestrong{scp}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cut and read Logwatch file} since the date fields (must be a daily Slice):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get day, month and year fields from the command} \sphinxstylestrong{date}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get the line number from the split must start with command} \sphinxstylestrong{grep \sphinxhyphen{}n}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get the number of line contained in the daily logwatch with the difference between the command} \sphinxstylestrong{wc \sphinxhyphen{}l} \sphinxstyleemphasis{result and the last one}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Cut the logwatch from the end with the command} \sphinxstylestrong{tail}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Reading filtered content} to get the correct Informations
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Split the daily logwatch content from the day starting line and month starting line}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Filtering Ip and User} fields from Regular Expressions
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Associate an user variable to the following regular expression filtered data :} \sphinxstylestrong{{[}A\sphinxhyphen{}Za\sphinxhyphen{}z0\sphinxhyphen{}9\_\sphinxhyphen{}êïù{]}+@{[}A\sphinxhyphen{}Za\sphinxhyphen{}z0\sphinxhyphen{}9\_\sphinxhyphen{}{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Associate an ip variable to the regular expression filtered data :} \sphinxstylestrong{({[}0\sphinxhyphen{}9{]}+\textbackslash{}.)\{3\}{[}0\sphinxhyphen{}9{]}+}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Associate to each User Token Event an Ip list} containing all the Inforamtions since the \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t} command output
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Store the differents ip address from the} \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t} \sphinxstyleemphasis{command into the IP\_slice list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{If the current item is an User field, associate to each user an IP list using the index count}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Increment the index at each user changing}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{For each User, stored in time, Computing the Cantor Difference between the two Ip Sets.} The result is the associated IP of the current User. In fact the first IP is immediatly avaible and permit to find the others from the principle of deduction:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{From the IP\_list, define the first user name and the first ip address as loop starter (all the others will be deducted from the first ones)}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Brownsing the array and make the absolute set difference between each stored ip address list to get the newest}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{The newest ip address is assigned to his respective hostname and stored into the User\_IP list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Print the result to use it in another script as raw output}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
The result is shown as a \sphinxstylestrong{user:ip} list association and is used in the \sphinxstylestrong{Get\_Origin\_Info\_v2.1.py} to make it faster.

\newpage
\section{Usage}
\label{\detokenize{Treat_log_v2.1:usage}}
\sphinxAtStartPar
Please to use with the correct syntax :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./Treat\PYGZus{}log\PYGZus{}v2.1.sh
\end{sphinxVerbatim}

\newpage
\section{Source}
\label{\detokenize{Treat_log_v2.1:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{} Author : CABOS Matthieu}
\PYG{c+c1}{\PYGZsh{} Date : 15/12/2021}

\PYG{c+c1}{\PYGZsh{} Cut and read Logwatch file since the date fiels (must be a daily Slice)}

scp mcabos@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}/logwatch .
\PYG{n+nv}{day}\PYG{o}{=}\PYG{l+s+sb}{`}date \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYGZhy{}f1\PYG{l+s+sb}{`}
\PYG{n+nv}{month}\PYG{o}{=}\PYG{l+s+sb}{`}date \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYGZhy{}f2\PYG{l+s+sb}{`}
\PYG{n+nv}{num}\PYG{o}{=}\PYG{l+s+sb}{`}date \PYG{p}{|} cut \PYGZhy{}d \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYGZhy{}f3\PYG{l+s+sb}{`}
\PYG{n+nv}{today}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}day}\PYG{l+s+s2}{ }\PYG{n+nv}{\PYGZdl{}month}\PYG{l+s+s2}{ }\PYG{n+nv}{\PYGZdl{}num}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nv}{cut\PYGZus{}line}\PYG{o}{=}\PYG{l+s+sb}{`}cat logwatch \PYG{p}{|} grep \PYGZhy{}n \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}today}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{|} head \PYGZhy{}1 \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K\PYGZca{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}
\PYG{n+nv}{nb\PYGZus{}line}\PYG{o}{=}\PYG{l+s+sb}{`}wc \PYGZhy{}l logwatch \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K\PYGZca{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}
\PYG{n+nv}{read\PYGZus{}line}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{k}{\PYGZdl{}((}\PYG{n+nv}{\PYGZdl{}nb\PYGZus{}line}\PYG{o}{\PYGZhy{}}\PYG{n+nv}{\PYGZdl{}cut\PYGZus{}line}\PYG{k}{))}\PYG{l+s+sb}{`}
\PYG{n+nv}{Content}\PYG{o}{=}\PYG{l+s+sb}{`}cat logwatch \PYG{p}{|} tail \PYGZhy{}\PYG{n+nv}{\PYGZdl{}read\PYGZus{}line}\PYG{l+s+sb}{`}
\PYG{n+nv}{Slice}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{Liste}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{CutFlag}\PYG{o}{=}\PYG{l+m}{0}

\PYG{c+c1}{\PYGZsh{} Reading filtered content to get the correct Informations}

\PYG{k}{for} line \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}Content}
\PYG{k}{do}
        \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}line} \PYG{o}{=}\PYG{o}{=} \PYG{n+nv}{\PYGZdl{}day} \PYG{o}{]} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}CutFlag} \PYGZhy{}eq \PYG{l+m}{1} \PYG{o}{]}
        \PYG{k}{then}
                \PYG{n+nv}{CutFlag}\PYG{o}{=}\PYG{l+m}{0}
                \PYG{n+nv}{Liste}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}Liste}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Slice}
                \PYG{n+nv}{Slice}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
        \PYG{k}{fi}
        \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}line} \PYG{o}{=}\PYG{o}{=} \PYG{n+nv}{\PYGZdl{}day} \PYG{o}{]} \PYG{o}{||} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}line} \PYG{o}{=}\PYG{o}{=} \PYG{n+nv}{\PYGZdl{}month} \PYG{o}{]}
        \PYG{k}{then}
                \PYG{n+nv}{CutFlag}\PYG{o}{=}\PYG{l+m}{1}
        \PYG{k}{fi}
        \PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}CutFlag} \PYGZhy{}eq \PYG{l+m}{1} \PYG{o}{]}
        \PYG{k}{then}
                \PYG{n+nv}{Slice}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}Slice}\PYG{n+nv}{\PYGZdl{}line}
        \PYG{k}{fi}
\PYG{k}{done}
\PYG{n+nv}{Liste}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}Liste}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}Slice}

\PYG{n+nv}{count}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{Liste2}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{k}{for} item \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}Liste}
\PYG{k}{do}
        \PYG{n+nv}{Liste2}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}Liste2}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}item}
        \PYG{n+nv}{count}\PYG{o}{=}\PYG{k}{\PYGZdl{}((}count+1\PYG{k}{))}
\PYG{k}{done}

\PYG{c+c1}{\PYGZsh{} Filtering Ip and User fields from Regular Expressions}

\PYG{n+nv}{IP\PYGZus{}Slice}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{User}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{ip}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{count}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nb}{declare} \PYGZhy{}a IP\PYGZus{}list

\PYG{c+c1}{\PYGZsh{} Associate to each User Token Event an Ip list containing all the Inforamtions since the ss \PYGZhy{}n \PYGZhy{}t command}

\PYG{k}{for} item \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}Liste2}
\PYG{k}{do}
        \PYG{n+nv}{User}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}item} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZus{}\PYGZhy{}êïù]+@[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZus{}\PYGZhy{}]+\PYGZdq{}}\PYG{l+s+sb}{`}
        \PYG{n+nv}{ip}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}item} \PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K([0\PYGZhy{}9]+\PYGZbs{}.)\PYGZob{}3\PYGZcb{}[0\PYGZhy{}9]+\PYGZdq{}}\PYG{l+s+sb}{`}
        \PYG{k}{for} elem \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}ip}
        \PYG{k}{do}
                \PYG{k}{if} ! \PYG{o}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}elem}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}10.14.14.20\PYGZdq{}} \PYG{o}{]}
                \PYG{k}{then}
                        \PYG{n+nv}{IP\PYGZus{}Slice}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}IP\PYGZus{}Slice}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}elem}\PYG{l+s+s2}{\PYGZdq{}}
                        \PYG{n+nv}{ip}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
                \PYG{k}{fi}
        \PYG{k}{done}
        \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYGZhy{}n \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}User}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]}\PYG{o}{]}
        \PYG{k}{then}
                IP\PYGZus{}list\PYG{o}{[}\PYG{n+nv}{\PYGZdl{}count}\PYG{o}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}User}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}IP\PYGZus{}Slice}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n+nv}{count}\PYG{o}{=}\PYG{k}{\PYGZdl{}((}count \PYG{o}{+} \PYG{l+m}{1}\PYG{k}{))}
        \PYG{k}{fi}
        \PYG{n+nv}{IP\PYGZus{}Slice}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
        \PYG{n+nv}{User}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{k}{done}

\PYG{n+nv}{User\PYGZus{}IP}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYG{n+nv}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} For each User, stored in time, Computing the Cantor Difference between the two Ip Sets. The result is the associated IP of the current User. In fact the first IP is immediatly avaible and permit to find the others from the principle of deduction.}

\PYG{n+nv}{User}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IP\PYGZus{}list}\PYG{p}{[1]}\PYG{l+s+si}{\PYGZcb{}}\PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZus{}\PYGZhy{}êïù]+@[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZus{}\PYGZhy{}]+\PYGZdq{}}\PYG{l+s+sb}{`}
readarray t \PYG{o}{\PYGZlt{}\PYGZlt{}\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{\PYGZdl{}(}\PYG{n+nb}{echo} \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IP\PYGZus{}list}\PYG{p}{[1]}\PYG{l+s+si}{\PYGZcb{}} \PYG{n+nv}{\PYGZdl{}tmp} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZbs{}n\PYGZsq{}} \PYG{p}{|} sort \PYG{p}{|} uniq \PYGZhy{}u\PYG{k}{)}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nv}{User\PYGZus{}IP}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}User}\PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{t}\PYG{p}{[0]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{k}{for} i \PYG{k}{in} \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{p}{!IP\PYGZus{}list[@]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{k}{do}
        \PYG{k}{if} \PYG{o}{[}\PYG{o}{[} \PYGZhy{}n \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}tmp}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]}\PYG{o}{]}
        \PYG{k}{then}
                readarray t \PYG{o}{\PYGZlt{}\PYGZlt{}\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{\PYGZdl{}(}\PYG{n+nb}{echo} \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IP\PYGZus{}list}\PYG{p}{[}\PYG{n+nv}{\PYGZdl{}i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}} \PYG{n+nv}{\PYGZdl{}tmp} \PYG{p}{|} tr \PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZbs{}n\PYGZsq{}} \PYG{p}{|} sort \PYG{p}{|} uniq \PYGZhy{}u\PYG{k}{)}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n+nv}{User}\PYG{o}{=}\PYG{l+s+sb}{`}\PYG{n+nb}{echo} \PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IP\PYGZus{}list}\PYG{p}{[}\PYG{n+nv}{\PYGZdl{}i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{p}{|} grep \PYGZhy{}Po \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}K[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZus{}\PYGZhy{}êïù]+@[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZus{}\PYGZhy{}]+\PYGZdq{}}\PYG{l+s+sb}{`}
                \PYG{k}{if} ! \PYG{o}{[}\PYG{o}{[} \PYG{n+nv}{\PYGZdl{}User\PYGZus{}IP} \PYG{o}{=} *\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}User}\PYG{l+s+s2}{\PYGZdq{}}* \PYG{o}{]}\PYG{o}{]}
                \PYG{k}{then}
                        \PYG{n+nv}{User\PYGZus{}IP}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}User\PYGZus{}IP}\PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}}\PYG{n+nv}{\PYGZdl{}User}\PYG{l+s+s2}{\PYGZdq{}:\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{t}\PYG{p}{[0]}\PYG{l+s+si}{\PYGZcb{}}
                \PYG{k}{fi}
        \PYG{k}{fi}
        \PYG{n+nv}{tmp}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{IP\PYGZus{}list}\PYG{p}{[}\PYG{n+nv}{\PYGZdl{}i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}
\PYG{k}{done}
\PYG{k}{for} item \PYG{k}{in} \PYG{n+nv}{\PYGZdl{}User\PYGZus{}IP}
\PYG{k}{do}
        \PYG{n+nb}{echo} \PYG{n+nv}{\PYGZdl{}item}
\PYG{k}{done}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Origin\_Users\_parallelisation\_v2}
\label{\detokenize{Origin_Users_parallelisation_v2:origin-users-parallelisation-v2}}\label{\detokenize{Origin_Users_parallelisation_v2::doc}}
\newpage
\section{Description}
\label{\detokenize{Origin_Users_parallelisation_v2:description}}
\sphinxAtStartPar
Here the pages dedied to the Pré\sphinxhyphen{}versions of the project.

\sphinxAtStartPar
The first one, called Origin\_Users\_parallelisation\_v2.py use the DHCP configuration ods file to retrieve the main informations.
The principe is a bit different and will be xplained function by function.

\sphinxAtStartPar
This is the main function of the algorithm used to update Origin History since log file.

\sphinxAtStartPar
This algorithm is ruled by followings steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting Users acount informations since the top level} : \sphinxstyleemphasis{Environnment variable getter}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Connecting an ssh session to the origin.srv\sphinxhyphen{}prive.icgm.fr server} : \sphinxstyleemphasis{Using netmiko module to automate authentified ssh session}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting raw users list Informations} : \sphinxstyleemphasis{From the output of the Origin Licence Request, Retrieve the connected users list}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting the Port Informations} : \sphinxstyleemphasis{From the} \sphinxstylestrong{netstat \sphinxhyphen{}anp} \sphinxstyleemphasis{command, retrieve the Origin server’s used port number}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting the raw IP list informations} : \sphinxstyleemphasis{From the} \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t} \sphinxstyleemphasis{command, Dress the list of present IP in connexion table}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting the raw hostname list Informations} : \sphinxstyleemphasis{From the} \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t \sphinxhyphen{}r} \sphinxstyleemphasis{command, Get the hostname list preset in connexion table}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Exit the ssh session and read the Ordinateurs.ods file} : \sphinxstyleemphasis{From the Ordinateurs.ods file, Fid and store all the others needed informations as MAC @, Vlan Id, …}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Updating the Origin\_history file since the newest Informations}

\end{itemize}

\sphinxAtStartPar
The results are dispayed at screen but could be write in an Origin History

\newpage
\section{Source}
\label{\detokenize{Origin_Users_parallelisation_v2:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Initialisation}

\PYG{n}{User\PYGZus{}list}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{IP}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{Nb\PYGZus{}Port}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{Host}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{IP\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{Host\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{Infos}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{User\PYGZus{}rep}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{Process\PYGZus{}List}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Launching section}

\PYG{n}{Cut\PYGZus{}log}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Update\PYGZus{}history}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rm logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{quit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Origin\_Users\_parallelisation\_v2\_API}
\label{\detokenize{Origin_Users_parallelisation_v2_API:origin-users-parallelisation-v2-api}}\label{\detokenize{Origin_Users_parallelisation_v2_API::doc}}
\sphinxAtStartPar
Here you will find all the associated functions to the Origin\_Users\_parallelisation\_v2 version.

\sphinxstepscope

\newpage
\section{get\_Port}
\label{\detokenize{OUP/get_Port:get-port}}\label{\detokenize{OUP/get_Port::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Port}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_Port:definition}}
\sphinxAtStartPar
Getting port number since the regular expressions using the output stdout from the ssh remote command output


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{output}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The ssh remote command output specified as parameter
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_Port:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Integer}

\sphinxAtStartPar
The port number used by the origin server.


\subsection{Source}
\label{\detokenize{OUP/get_Port:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Port}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[0\PYGZhy{}9]*}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{maxi}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{matches} \PYG{o}{=} \PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,} \PYG{n}{output}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{port}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{k}{pass}
                \PYG{k}{if} \PYG{n}{port} \PYG{o}{\PYGZgt{}} \PYG{n}{maxi}\PYG{p}{:}
                        \PYG{n}{maxi}\PYG{o}{=}\PYG{n}{port}
        \PYG{k}{return} \PYG{n}{maxi}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_IP\_list}
\label{\detokenize{OUP/get_IP_list:get-ip-list}}\label{\detokenize{OUP/get_IP_list::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}IP\PYGZus{}list}\PYG{p}{(}\PYG{n}{IP}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_IP_list:definition}}
\sphinxAtStartPar
Getting IP list since the regular expressions using the output stdout from the ssh remote command output
The filtering operation is done in multiline mode and will be coursed match by match.
The result is shown as a list of ip address.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IP}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The ssh remote command output specified as parameter
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_IP_list:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String List}

\sphinxAtStartPar
The list containing all the ipaddress founded in the ssh remote command output.


\subsection{Source}
\label{\detokenize{OUP/get_IP_list:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}IP\PYGZus{}list}\PYG{p}{(}\PYG{n}{IP}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{banned}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{127.0.0.1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.9}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{([0\PYGZhy{}9]*}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s2}{[0\PYGZhy{}9]+}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{matches} \PYG{o}{=} \PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,} \PYG{n}{IP}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{tmp}\PYG{p}{:}
                \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{banned}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
        \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{dict}\PYG{o}{.}\PYG{n}{fromkeys}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_Host\_list}
\label{\detokenize{OUP/get_Host_list:get-host-list}}\label{\detokenize{OUP/get_Host_list::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Host\PYGZus{}list}\PYG{p}{(}\PYG{n}{Host}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_Host_list:definition}}
\sphinxAtStartPar
Getting Host list since the regular expressions using the output stdout from the ssh remote command output.
Brownsing the string output line by line and filter each line independantly from the others to get the correct hostnames contained.
The hostnames have form \sphinxstyleemphasis{name.dsi0.icgm.fr:60213}, this is the form present into the output of a \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t \sphinxhyphen{}r} command.

\sphinxAtStartPar
The result is the sorted list of the hostnames. To sort them, I use the \sphinxstylestrong{list(dict.fromkeys(liste))} command


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Host}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The ssh remote command output specified as parameter
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_Host_list:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String List}

\sphinxAtStartPar
A list containing all the hostnames founded into the ssh remote command output.


\subsection{Source}
\label{\detokenize{OUP/get_Host_list:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Host\PYGZus{}list}\PYG{p}{(}\PYG{n}{Host}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[A\PYGZhy{}Z\PYGZhy{}]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.[dsi0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.icgm.fr:[0\PYGZhy{}9]*}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{Host\PYGZus{}real}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{Host\PYGZus{}list}\PYG{o}{=}\PYG{n}{Host}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Host\PYGZus{}list}\PYG{p}{:}
                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{Host\PYGZus{}real}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}[a\PYGZhy{}zA\PYGZhy{}Z0\PYGZhy{}9\PYGZus{}\PYGZhy{}]*}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{matches} \PYG{o}{=} \PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,} \PYG{n}{Host\PYGZus{}real}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{return} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{dict}\PYG{o}{.}\PYG{n}{fromkeys}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Read\_ods}
\label{\detokenize{OUP/Read_ods:read-ods}}\label{\detokenize{OUP/Read_ods::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Read\PYGZus{}ods}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{n}{Host\PYGZus{}list}\PYG{p}{,}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Read_ods:definition}}
\sphinxAtStartPar
Reading the Ordinateurs.ods file to get associated MAC\_@ \& Departement ID.
The Ordinateurs.ods file contain all the authorized host into the DHCP server (and so the MAC address and the Departement ID).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{path}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
Define the path of the .ods file to read
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Host\_list}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The given Hostname list to find values into the ods file content
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IP\_list}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The given IP list to link the differents informations together
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/Read_ods:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String List}

\sphinxAtStartPar
The List repertoring the following informations as item :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Hostname

\item {} 
\sphinxAtStartPar
MAC address

\item {} 
\sphinxAtStartPar
Departemet ID

\item {} 
\sphinxAtStartPar
IP address

\end{itemize}


\subsection{Source}
\label{\detokenize{OUP/Read_ods:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Read\PYGZus{}ods}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{n}{Host\PYGZus{}list}\PYG{p}{,}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{records} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{get\PYGZus{}array}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{o}{=}\PYG{n}{path}\PYG{p}{)}
        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{mac}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{for} \PYG{n}{record} \PYG{o+ow}{in} \PYG{n}{records}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{Host\PYGZus{}list}\PYG{p}{:}
                        \PYG{n}{ind}\PYG{o}{=}\PYG{n}{Host\PYGZus{}list}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
                        \PYG{n}{mac}\PYG{o}{=}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{o}{+}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{:}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{]}\PYG{o}{+}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{]}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mac}\PYG{p}{,}\PYG{n}{record}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{IP\PYGZus{}list}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
                        \PYG{n}{mac}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{ssh\_session\_Treat\_info}
\label{\detokenize{OUP/ssh_session_Treat_info:ssh-session-treat-info}}\label{\detokenize{OUP/ssh_session_Treat_info::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ssh\PYGZus{}session\PYGZus{}Treat\PYGZus{}info}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{IPSwitchs}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/ssh_session_Treat_info:definition}}
\sphinxAtStartPar
Automated authentified ssh session with parameters.
The associated remote command is \sphinxstylestrong{sh mac address\sphinxhyphen{}table} to automate the Cisco request y ssh.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{cisco}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The Cisco Switch name to connect
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IPSwitchs}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary associating to each Switch name its IP address
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/ssh_session_Treat_info:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String}

\sphinxAtStartPar
The raw output of the ssh remote command


\subsection{Source}
\label{\detokenize{OUP/ssh_session_Treat_info:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ssh\PYGZus{}session\PYGZus{}Treat\PYGZus{}info}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{IPSwitchs}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/cisco}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco\PYGZus{}ios}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{n}{IPSwitchs}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
        \PYG{n}{output}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sh mac address\PYGZhy{}table}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{output}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Treat\_Info}
\label{\detokenize{OUP/Treat_Info:treat-info}}\label{\detokenize{OUP/Treat_Info::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}Info}\PYG{p}{(}\PYG{n}{Infos}\PYG{p}{,}\PYG{n}{IPSwitchs}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Treat_Info:definition}}
\sphinxAtStartPar
Treat Infos getted since the ods file and the ssh output both. Etablishing a link between the MAC\_@ and the Cisco Socket Number.
The result will be stored in a ‘ready to print’ list.
This function is ruled by a looped algorithm :

\sphinxAtStartPar
\sphinxstylestrong{for each cisco in the network} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{request the associated cisco}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{get the Cisco gigabitethernet socket} from the \sphinxstylestrong{sh mac address\sphinxhyphen{}table} output :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Filter by the following regular expression} : \sphinxstylestrong{Gi({[}0\sphinxhyphen{}9{]}\textbackslash{}/)\{2\}{[}0\sphinxhyphen{}9{]}+}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Store the informations} with form : \sphinxstyleemphasis{‘Cisco : | Vlan / Mac\_@ / GiB : | Host : | Dpt : | IP\_@ ‘}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Infos}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String list}
&
\sphinxAtStartPar
A list containing all the needed informations linked to an user
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IPSwitchs}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary associating to each Switch name its IP address
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/Treat_Info:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String List}

\sphinxAtStartPar
‘Ready to print’ String list where each item is associated with a user and have form : \sphinxstyleemphasis{‘Cisco : | Vlan / Mac\_@ / GiB : | Host : | Dpt : | IP\_@ ‘}


\subsection{Source}
\label{\detokenize{OUP/Treat_Info:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}Info}\PYG{p}{(}\PYG{n}{Infos}\PYG{p}{,}\PYG{n}{IPSwitchs}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{cisco} \PYG{o+ow}{in} \PYG{n}{IPSwitchs}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{out}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
                \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/cisco}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco\PYGZus{}ios}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{n}{IPSwitchs}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
                \PYG{n}{output}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sh mac address\PYGZhy{}table}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
                \PYG{c+c1}{\PYGZsh{} output=ssh\PYGZus{}session\PYGZus{}Treat\PYGZus{}info(cisco,IPSwitchs)}
                \PYG{n}{out}\PYG{o}{=}\PYG{n}{output}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gi([0\PYGZhy{}9]}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{/)}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{k}{for} \PYG{n}{info} \PYG{o+ow}{in} \PYG{n}{Infos}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{out}\PYG{p}{:}
                                \PYG{k}{if} \PYG{n}{info}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
                                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,} \PYG{n}{line} \PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{k}{if} \PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!=} \PYG{k+kc}{None} \PYG{p}{:}
                                                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cisco : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | Vlan / Mac\PYGZus{}@ / GiB : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{36}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | Host : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{info}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | Dpt :  }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{info}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | Ip\PYGZus{}@ : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{info}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{o}{==}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Infos}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{k}{return} \PYG{n}{res}
        \PYG{k}{return}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Write\_in\_file}
\label{\detokenize{OUP/Write_in_file:write-in-file}}\label{\detokenize{OUP/Write_in_file::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Write\PYGZus{}in\PYGZus{}file}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{,}\PYG{n}{path}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Write_in_file:definition}}
\sphinxAtStartPar
Write/Update Infos in file from the path name.
The Infos parameter must be with type Sorted String List as defined in the Treat\_Info method.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{to\_write}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The full content to write as defined in the treat\_Info method
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{path}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The raw path of the fle to write/update
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Source}
\label{\detokenize{OUP/Write_in_file:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Write\PYGZus{}in\PYGZus{}file}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{,}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}write}\PYG{p}{:}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_Description}
\label{\detokenize{OUP/get_Description:get-description}}\label{\detokenize{OUP/get_Description::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Description}\PYG{p}{(}\PYG{n}{Data}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_Description:definition}}
\sphinxAtStartPar
Updating Socket Description field and add a timestamp to the Information.
To do so, I’m uing the following regular expressions :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Cisco socket getter} : \sphinxstylestrong{Gi({[}0\sphinxhyphen{}9{]}\textbackslash{}/)\{2\}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Outlet Description getter} : \sphinxstylestrong{{[}NRJPASEP{]}+{[}0\sphinxhyphen{}9{]}+{[}A\sphinxhyphen{}K{]}{[}0\sphinxhyphen{}9{]}+\sphinxhyphen{}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Cisco Name getter} : \sphinxstylestrong{Balard\sphinxhyphen{}{[}EPACRDGH1234{]}+\sphinxhyphen{}{[}0\sphinxhyphen{}9{]}}

\end{itemize}

\sphinxAtStartPar
Foreach dataline in the Data list:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Filter the two needed fields and store them in their respective variable cisco and socket

\item {} 
\sphinxAtStartPar
use a ssn session to get the output of the command \sphinxstylestrong{show interface gigabitethernet}

\item {} 
\sphinxAtStartPar
Filter the output with the Outlet Description getter expression

\item {} 
\sphinxAtStartPar
Add the Description field to the dataline

\item {} 
\sphinxAtStartPar
Rebuild a full Data list as result

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{3}{\X{1}{3}|}}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Desccription}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Data}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The String Datas as list, each dataline contain the following informations :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cisco Name

\item {} 
\sphinxAtStartPar
Vlan id

\item {} 
\sphinxAtStartPar
MAC address

\item {} 
\sphinxAtStartPar
Cisco Socket

\item {} 
\sphinxAtStartPar
Hostname

\item {} 
\sphinxAtStartPar
Departemet id

\item {} 
\sphinxAtStartPar
IP address

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_Description:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String List}

\sphinxAtStartPar
The updated Data list with description field


\subsection{Source}
\label{\detokenize{OUP/get_Description:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Description}\PYG{p}{(}\PYG{n}{Data}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gi([0\PYGZhy{}9]}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{/)}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex2}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[NRJPASEP]+[0\PYGZhy{}9]+[A\PYGZhy{}K][0\PYGZhy{}9]+\PYGZhy{}[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex3}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}[EPACRDGH1234]+\PYGZhy{}[0\PYGZhy{}9]}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{socket}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{description}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}

        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/cisco}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Data}\PYG{p}{:}
                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex3}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{cisco}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{socket}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco\PYGZus{}ios}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{n}{IPSwitchs}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
                \PYG{n}{output}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{show interface gigabitethernet }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{socket}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex2}\PYG{p}{,} \PYG{n}{output}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{description}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{item}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | Socket Description : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{description}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{cisco}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{socket}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{description}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{reverse}
\label{\detokenize{OUP/reverse:reverse}}\label{\detokenize{OUP/reverse::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/reverse:definition}}
\sphinxAtStartPar
Standard list reverse function


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
List
&
\sphinxAtStartPar
The list to reverse
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/reverse:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{List}

\sphinxAtStartPar
The reversed list


\subsection{Source}
\label{\detokenize{OUP/reverse:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_time}
\label{\detokenize{OUP/get_time:get-time}}\label{\detokenize{OUP/get_time::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}time}\PYG{p}{(}\PYG{n}{Data}\PYG{p}{,}\PYG{n}{User\PYGZus{}rep}\PYG{p}{,}\PYG{n}{User\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_time:definition}}
\sphinxAtStartPar
Getting exact time duration since already recorded timestamp and add it to the Main Data List.
This method is ruled by the followings steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
foreach dataline in Datas :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Get the IP address since regular expression filtering

\item {} 
\sphinxAtStartPar
Get the name and check if present in the User\_list

\item {} 
\sphinxAtStartPar
If present, associate a timestamp

\item {} 
\sphinxAtStartPar
If the timestamp is defined, compute the difference between the now timestamp and the starting timestamp to get the Connexion time elapsed

\item {} 
\sphinxAtStartPar
Update the Data list with the Time Elapsed field

\end{itemize}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{3}{\X{1}{3}|}}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Data}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The String Datas as list, each dataline contain the following informations :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cisco Name

\item {} 
\sphinxAtStartPar
Vlan id

\item {} 
\sphinxAtStartPar
MAC address

\item {} 
\sphinxAtStartPar
Cisco Socket

\item {} 
\sphinxAtStartPar
Hostname

\item {} 
\sphinxAtStartPar
Departemet id

\item {} 
\sphinxAtStartPar
IP address

\item {} 
\sphinxAtStartPar
Socket Description

\end{itemize}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{User\_rep}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The users dictionnary extracted from the logwatch file linking to an user his strating timestamp
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{User\_list}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The User dictionnary  extracted from the logwatch file linking to an user his IP address
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_time:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String List}

\sphinxAtStartPar
The updated Data list with field Time Elapsed


\subsection{Source}
\label{\detokenize{OUP/get_time:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}time}\PYG{p}{(}\PYG{n}{Data}\PYG{p}{,}\PYG{n}{User\PYGZus{}rep}\PYG{p}{,}\PYG{n}{User\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{tmp\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{timestamp}\PYG{o}{=}\PYG{l+m+mf}{0.0}
        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{now}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Data}\PYG{p}{:}
                \PYG{n}{tmp\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{ip}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{ip} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{tmp\PYGZus{}name}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}list}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{if} \PYG{n}{tmp\PYGZus{}name} \PYG{o+ow}{in}  \PYG{n}{name}\PYG{p}{:}
                                        \PYG{n}{timestamp}\PYG{o}{=}\PYG{n}{User\PYGZus{}list}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}
                                        \PYG{k}{break}
                                \PYG{k}{else}\PYG{p}{:}
                                        \PYG{n}{timestamp}\PYG{o}{=}\PYG{l+m+mf}{0.0}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{timestamp}\PYG{p}{)}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{now}\PYG{p}{)}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{now}\PYG{o}{\PYGZhy{}}\PYG{n}{timestamp}\PYG{p}{)}
                        \PYG{k}{if} \PYG{p}{(}\PYG{n}{timestamp} \PYG{o}{!=} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{item}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | pseudo = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | Time Elapsed = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{p}{(}\PYG{n}{now}\PYG{o}{\PYGZhy{}}\PYG{n}{timestamp}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ min}\PYG{l+s+s1}{\PYGZsq{}}
                                \PYG{n}{timestamp}\PYG{o}{=}\PYG{l+m+mf}{0.0}
                        \PYG{k}{else}\PYG{p}{:}
                                \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{item}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | pseudo = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ | Time Elapsed not avaible}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{item}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{k}{return} \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{treat\_Users}
\label{\detokenize{OUP/treat_Users:treat-users}}\label{\detokenize{OUP/treat_Users::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{treat\PYGZus{}Users}\PYG{p}{(}\PYG{n}{Users}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/treat_Users:definition}}
\sphinxAtStartPar
Managing Tokens allocation (Time Elapsed since the first Token).
This method read the content of the requested Licence file.

\sphinxAtStartPar
Differents regular expressions manage the results :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{month} : \sphinxstylestrong{{[}0\sphinxhyphen{}9{]}+\textbackslash{}/+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{day} : \sphinxstylestrong{{[}\textasciicircum{}a\sphinxhyphen{}z{]}\textbackslash{}/{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{hour} : \sphinxstylestrong{{[}0\sphinxhyphen{}9{]}+\textbackslash{}:}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{minuts} : \sphinxstylestrong{\textbackslash{}:{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{user} : \sphinxstylestrong{\textasciicircum{}\textbackslash{}s*{[}\textasciicircum{}:\textbackslash{}s{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{PC} : \sphinxstylestrong{{[}A\sphinxhyphen{}Z0\sphinxhyphen{}9{]}+\sphinxhyphen{}{[}A\sphinxhyphen{}Z0\sphinxhyphen{}9{]}+}

\end{itemize}

\sphinxAtStartPar
Once the differents fields retireved from regular expressions, the return dictionnary is populated with users name and the linked timestamp.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Users}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The output of the Origin Licence Request to get Connected users
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/treat_Users:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The dictionnary associating to an user name its connexion starting timestamp


\subsection{Source}
\label{\detokenize{OUP/treat_Users:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{treat\PYGZus{}Users}\PYG{p}{(}\PYG{n}{Users}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{Jeton\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{/+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex2}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[\PYGZca{}a\PYGZhy{}z]}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{/[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex3}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex4}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex5}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{s*[\PYGZca{}:}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{s]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex6}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[A\PYGZhy{}Z0\PYGZhy{}9]+\PYGZhy{}[A\PYGZhy{}Z0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{User\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{User\PYGZus{}list}\PYG{o}{=}\PYG{n}{Users}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

        \PYG{k}{if} \PYG{n}{Users}\PYG{o}{!=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}

                \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{User\PYGZus{}list}\PYG{p}{:}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{month}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex2}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{day}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex3}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{hour}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex4}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{minuts}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex5}\PYG{p}{,}\PYG{n}{item}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{user}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex6}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{PC}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
                        \PYG{n}{user}\PYG{o}{=}\PYG{n}{user}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{PC}
                        \PYG{n}{date}\PYG{o}{=}\PYG{n}{d}\PYG{o}{.}\PYG{n}{datetime}\PYG{p}{(}\PYG{l+m+mi}{2021}\PYG{p}{,}\PYG{n}{month}\PYG{p}{,}\PYG{n}{day}\PYG{p}{,}\PYG{n}{hour}\PYG{p}{,}\PYG{n}{minuts}\PYG{p}{)}
                        \PYG{n}{User\PYGZus{}dic}\PYG{p}{[}\PYG{n}{user}\PYG{p}{]}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{mktime}\PYG{p}{(}\PYG{n}{date}\PYG{o}{.}\PYG{n}{timetuple}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{return} \PYG{n}{User\PYGZus{}dic}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{return} \PYG{k+kc}{None}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{cut\_dic}
\label{\detokenize{OUP/cut_dic:cut-dic}}\label{\detokenize{OUP/cut_dic::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/cut_dic:definition}}
\sphinxAtStartPar
Split Dictionnary into div differents dictionnary to treat them with parallelism.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Cisco\_Dic}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The Cisco 2 Ip main dictionnary
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{div}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Integer}
&
\sphinxAtStartPar
The number of dictionnary slice needed
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/cut_dic:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary List}

\sphinxAtStartPar
A list af \sphinxstyleemphasis{div} differents dictiononary


\subsection{Source}
\label{\detokenize{OUP/cut_dic:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{)}\PYG{o}{/}\PYG{n}{div}\PYG{p}{)}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Cisco\PYGZus{}Dic}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}
                \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{ind}\PYG{o}{==}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
                        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Cut\_log}
\label{\detokenize{OUP/Cut_log:cut-log}}\label{\detokenize{OUP/Cut_log::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Cut\PYGZus{}log}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Cut_log:definition}}
\sphinxAtStartPar
Cut logfile since the date (today as default).
The logwatch file is primary stored into the local folder.
Once done, It cut the logwatch file since the today date.

\sphinxAtStartPar
It write the daily logwatch content instead of your local copy of the logwatch file.


\subsection{Source}
\label{\detokenize{OUP/Cut_log:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Cut\PYGZus{}log}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{k}{try}\PYG{p}{:}
                \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp mcabos@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}/logwatch .}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{except}\PYG{p}{:}
                \PYG{k}{pass}

        \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{date}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{Content}\PYG{o}{=}\PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{False}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

        \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{Content}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{date}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{)} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{Keep\PYGZus{}flag}\PYG{p}{:}
                        \PYG{n}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{True}
                \PYG{k}{if} \PYG{n}{Keep\PYGZus{}flag}\PYG{p}{:}
                        \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}write}\PYG{p}{:}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{read\_log}
\label{\detokenize{OUP/read_log:read-log}}\label{\detokenize{OUP/read_log::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}log}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/read_log:definition}}
\sphinxAtStartPar
Read the log file and filter the content by regular expression to get the main content of the logwatch file.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{path}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The path where the logwatch is stored
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/read_log:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{List of List}

\sphinxAtStartPar
The list of list containing the main content sorrted by token in order


\subsection{Source}
\label{\detokenize{OUP/read_log:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}log}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[a\PYGZhy{}z]+([\PYGZca{}a\PYGZhy{}z]+.*[0\PYGZhy{}9]*}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{n)+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{match\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{Content}\PYG{o}{=}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,} \PYG{n}{Content}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{match\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n}{match\PYGZus{}list}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Treat\_log}
\label{\detokenize{OUP/Treat_log:treat-log}}\label{\detokenize{OUP/Treat_log::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}log}\PYG{p}{(}\PYG{n}{match\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Treat_log:definition}}
\sphinxAtStartPar
Treat Log file content since regular expression to get
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{IP\_@ list} : \sphinxstylestrong{({[}0\sphinxhyphen{}9{]}+\textbackslash{}.)+{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{New user information} : \sphinxstylestrong{{[}A\sphinxhyphen{}Za\sphinxhyphen{}zëùî0\sphinxhyphen{}9{]}+@{[}A\sphinxhyphen{}Z0\sphinxhyphen{}9{]}+\sphinxhyphen{}{[}A\sphinxhyphen{}Z0\sphinxhyphen{}9{]}+}

\end{itemize}

\sphinxAtStartPar
The content analized is the outputof the read\_log method sorted by token.
This function link an user to an ip list. This ip list contain all the suceptible ip for this user.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{match\_list}
&
\sphinxAtStartPar
\sphinxstyleemphasis{List of List}
&
\sphinxAtStartPar
The list of list containing the main content sorrted by token in order
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/Treat_log:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
A dictionnary associating to an user name the associated ip address list from the logwatch file content


\subsection{Source}
\label{\detokenize{OUP/Treat_log:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}log}\PYG{p}{(}\PYG{n}{match\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)+[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex2}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[A\PYGZhy{}Za\PYGZhy{}zëùî0\PYGZhy{}9]+@[A\PYGZhy{}Z0\PYGZhy{}9]+\PYGZhy{}[A\PYGZhy{}Z0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{banned}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{user}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{User\PYGZus{}list}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{Dic\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{True}
        \PYG{n}{index}\PYG{o}{=}\PYG{l+m+mi}{0}

        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{match\PYGZus{}list}\PYG{p}{:}
                \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{item}\PYG{p}{:}

                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,} \PYG{n}{line}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{n}{matches2}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex2}\PYG{p}{,} \PYG{n}{line}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches2}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{Dic\PYGZus{}flag}\PYG{o}{=}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{o}{==}\PYG{k+kc}{None}\PYG{p}{)}
                                \PYG{n}{user}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{if} \PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{banned}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{tmp}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{Dic\PYGZus{}flag}\PYG{p}{:}
                                \PYG{n}{User\PYGZus{}list}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{n}{tmp}
                                \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
                                \PYG{n}{Dic\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{True}
                                \PYG{n}{index}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{return} \PYG{n}{User\PYGZus{}list}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{diff\_list}
\label{\detokenize{OUP/diff_list:diff-list}}\label{\detokenize{OUP/diff_list::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{diff\PYGZus{}list}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{,}\PYG{n}{l2}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/diff_list:definition}}
\sphinxAtStartPar
Compute difference between 2 lists to get the most suceptible ip to assign.

\sphinxAtStartPar
The difference between \sphinxstylestrong{two set A and B (A\sphinxhyphen{}B)} give us the ip addresses present in \sphinxstylestrong{A} but \sphinxstylestrong{NOT in B}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{l1}
&
\sphinxAtStartPar
\sphinxstyleemphasis{List}
&
\sphinxAtStartPar
An Ip list extracted from the Treat\_log method return dictionnary
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{l2}
&
\sphinxAtStartPar
\sphinxstyleemphasis{List}
&
\sphinxAtStartPar
An Ip list extracted from the Treat\_log method return dictionnary
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/diff_list:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String List}

\sphinxAtStartPar
The list containing the difference between l1 and l2


\subsection{Source}
\label{\detokenize{OUP/diff_list:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{diff\PYGZus{}list}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{,}\PYG{n}{l2}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l1}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{m}\PYG{o}{=}\PYG{n}{l1}
                \PYG{n}{n}\PYG{o}{=}\PYG{n}{l2}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{m}\PYG{o}{=}\PYG{n}{l2}
                \PYG{n}{n}\PYG{o}{=}\PYG{n}{l1}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{m}\PYG{p}{:}
                \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{n}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Diff\_log}
\label{\detokenize{OUP/Diff_log:diff-log}}\label{\detokenize{OUP/Diff_log::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Diff\PYGZus{}log}\PYG{p}{(}\PYG{n}{User\PYGZus{}dic}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Diff_log:definition}}
\sphinxAtStartPar
Associate a new user to the difference between 2 log slice. Results will be stored into a python dictionnary.

\sphinxAtStartPar
This function is ruled by the following instructions :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Brownsing the User\_dic dictionnary} and filter the hostname by regular expression

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Computing the difference between two adjacents lists} using the diff\_list function

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Associate to an user name its own ip addresses set}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{User\_dic}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary associating to an user name the associated ip address list from the logwatch file content from the Treat\_log function
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/Diff_log:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The dictionnary associating to an user name an ip addresses set.


\subsection{Source}
\label{\detokenize{OUP/Diff_log:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Diff\PYGZus{}log}\PYG{p}{(}\PYG{n}{User\PYGZus{}dic}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{res}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{User\PYGZus{}dic}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{tmp}\PYG{p}{:}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{v}
                        \PYG{n}{res}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{diff}\PYG{o}{=}\PYG{n}{diff\PYGZus{}list}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{tmp}\PYG{p}{)}
                        \PYG{n}{res}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{diff}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{v}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Treat\_diff}
\label{\detokenize{OUP/Treat_diff:treat-diff}}\label{\detokenize{OUP/Treat_diff::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}diff}\PYG{p}{(}\PYG{n}{User\PYGZus{}dic}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Treat_diff:definition}}
\sphinxAtStartPar
Compute the \sphinxstylestrong{Set difference by User ID} between two sets of ip address to get the correct one.

\sphinxAtStartPar
In fact treat the output of the \sphinxstylestrong{Diff\_log} function (removing indexes and merge list if necessary)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{User\_dic}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary associating to an user name an ip addresses set from the Diff\_log function
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/Treat_diff:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The updated dictionnary associating to an user name an ip addresses


\subsection{Source}
\label{\detokenize{OUP/Treat_diff:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Treat\PYGZus{}diff}\PYG{p}{(}\PYG{n}{User\PYGZus{}dic}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{regex}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[A\PYGZhy{}Za\PYGZhy{}zëùî0\PYGZhy{}9]+@[A\PYGZhy{}Z0\PYGZhy{}9]+\PYGZhy{}[A\PYGZhy{}Z0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{index}\PYG{o}{=}\PYG{l+m+mi}{0}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{User\PYGZus{}dic}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{if} \PYG{n}{index}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10} \PYG{p}{:}
                                \PYG{n}{name}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
                        \PYG{k}{elif} \PYG{n}{index} \PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{10} \PYG{o+ow}{and} \PYG{n}{index}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{100}\PYG{p}{:}
                                \PYG{n}{name}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}
                        \PYG{k}{elif} \PYG{n}{index} \PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{100} \PYG{o+ow}{and} \PYG{n}{index}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1000}\PYG{p}{:}
                                \PYG{n}{name}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
                        \PYG{k}{elif} \PYG{n}{index} \PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{1000} \PYG{o+ow}{and} \PYG{n}{index}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10000}\PYG{p}{:}
                                \PYG{n}{name}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}
                        \PYG{n}{index}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{k}{if} \PYG{n}{v} \PYG{p}{:}
                        \PYG{k}{try}\PYG{p}{:}
                                \PYG{n}{res}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                        \PYG{k}{except}\PYG{p}{:}
                                \PYG{n}{res}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_max}
\label{\detokenize{OUP/get_max:get-max}}\label{\detokenize{OUP/get_max::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}max}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_max:definition}}
\sphinxAtStartPar
Get the max value’s index of the list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{List}
&
\sphinxAtStartPar
Integer or Float list to treat
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_max:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Integer / Float}

\sphinxAtStartPar
The index of the maximum value of the list


\subsection{Source}
\label{\detokenize{OUP/get_max:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}max}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{maxi}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{liste}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{item} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{maxi}\PYG{p}{:}
                        \PYG{n}{maxi}\PYG{o}{=}\PYG{n}{item}
        \PYG{k}{return} \PYG{n}{liste}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{maxi}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_ip}
\label{\detokenize{OUP/get_ip:get-ip}}\label{\detokenize{OUP/get_ip::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ip}\PYG{p}{(}\PYG{n}{User\PYGZus{}dic}\PYG{p}{,}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_ip:definition}}
\sphinxAtStartPar
Get the real (most susceptible one) IP\_@ from an user name using successives reults from functions :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{read\_log}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_log}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Diff\_log}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_diff}

\end{itemize}

\sphinxAtStartPar
The favorite IP is choosen by number of appearence into the merged list of suceptibles ip address from difference.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{User\_dic}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary from the successive intermediate functions associating an user a merged list of candidates
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IP\_list}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The IP list of connected users
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_ip:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The Final dictionnary associating to an user the most suceptible IP address from logwatch analyze


\subsection{Source}
\label{\detokenize{OUP/get_ip:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}ip}\PYG{p}{(}\PYG{n}{User\PYGZus{}dic}\PYG{p}{,}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{favorite}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{ip\PYGZus{}id}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{count}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{32}
        \PYG{n}{index}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{User\PYGZus{}rep}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{User\PYGZus{}dic}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{ip\PYGZus{}id}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{dict}\PYG{o}{.}\PYG{n}{fromkeys}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{ip} \PYG{o+ow}{in} \PYG{n}{ip\PYGZus{}id}\PYG{p}{:}
                        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{ip} \PYG{o+ow}{in} \PYG{n}{IP\PYGZus{}list}\PYG{p}{:}
                                \PYG{n}{ip\PYGZus{}id}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}
                \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ip\PYGZus{}id}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{ip} \PYG{o+ow}{in} \PYG{n}{ip\PYGZus{}id}\PYG{p}{:}
                                \PYG{n}{count}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}
                                \PYG{n}{index}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                        \PYG{n}{favorite}\PYG{o}{=}\PYG{n}{ip\PYGZus{}id}\PYG{p}{[}\PYG{n}{get\PYGZus{}max}\PYG{p}{(}\PYG{n}{count}\PYG{p}{)}\PYG{p}{]}
                        \PYG{n}{count}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{32}
                        \PYG{n}{index}\PYG{o}{=}\PYG{l+m+mi}{0}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{favorite}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                \PYG{n}{User\PYGZus{}rep}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{favorite}
                \PYG{n}{favorite}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{return} \PYG{n}{User\PYGZus{}rep}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{diff\_ip}
\label{\detokenize{OUP/diff_ip:diff-ip}}\label{\detokenize{OUP/diff_ip::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{diff\PYGZus{}ip}\PYG{p}{(}\PYG{n}{ipA}\PYG{p}{,}\PYG{n}{ipB}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/diff_ip:definition}}
\sphinxAtStartPar
Get the raw difference between 2 ip address.

\sphinxAtStartPar
Exemple :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{IP\_a} =10.14.20.1

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{IP\_b} =10.14.2 \sphinxstylestrong{1.3}

\end{itemize}

\sphinxAtStartPar
The difference will be \sphinxstylestrong{1.3}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{ipA}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
IP address to compare
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{ipB}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
IP address to compare
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/diff_ip:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{String}

\sphinxAtStartPar
The raw difference between both of the ip address


\subsection{Source}
\label{\detokenize{OUP/diff_ip:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{diff\PYGZus{}ip}\PYG{p}{(}\PYG{n}{ipA}\PYG{p}{,}\PYG{n}{ipB}\PYG{p}{)}\PYG{p}{:}

        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipA}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipB}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipA}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipB}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{ipB}\PYG{o}{+}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{elif} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipB}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipA}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{while} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipA}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ipB}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{ipA}\PYG{o}{+}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{y} \PYG{k}{for} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n}{it}\PYG{o}{.}\PYG{n}{zip\PYGZus{}longest}\PYG{p}{(}\PYG{n}{ipA}\PYG{p}{,}\PYG{n}{ipB}\PYG{p}{)} \PYG{k}{if} \PYG{n}{x} \PYG{o}{!=} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_IP\_from\_log}
\label{\detokenize{OUP/get_IP_from_log:get-ip-from-log}}\label{\detokenize{OUP/get_IP_from_log::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}IP\PYGZus{}from\PYGZus{}log}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/get_IP_from_log:definition}}
\sphinxAtStartPar
DHCP data finder Main Resolution Algorithm.
This algorithm use and manage the functions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{read\_log}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_log}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Diff\_log}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Treat\_diff}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{get\_ip}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{diff\_ip}

\end{itemize}

\sphinxAtStartPar
It restore the final dictionnary associating to an user its ip address.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IP\_list}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The list extracted from the command’s output \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{OUP/get_IP_from_log:returns}}
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}

\sphinxAtStartPar
The Final dictionnary associating to an user the most suceptible IP address from logwatch analyze


\subsection{Source}
\label{\detokenize{OUP/get_IP_from_log:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}IP\PYGZus{}from\PYGZus{}log}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{not\PYGZus{}assigned}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{current}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{mini}\PYG{o}{=}\PYG{l+m+mi}{10}

        \PYG{n}{test}\PYG{o}{=}\PYG{n}{read\PYGZus{}log}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{test2}\PYG{o}{=}\PYG{n}{Treat\PYGZus{}log}\PYG{p}{(}\PYG{n}{test}\PYG{p}{)}
        \PYG{n}{test3}\PYG{o}{=}\PYG{n}{Diff\PYGZus{}log}\PYG{p}{(}\PYG{n}{test2}\PYG{p}{)}
        \PYG{n}{test4}\PYG{o}{=}\PYG{n}{Treat\PYGZus{}diff}\PYG{p}{(}\PYG{n}{test3}\PYG{p}{)}
        \PYG{n}{test5}\PYG{o}{=}\PYG{n}{get\PYGZus{}ip}\PYG{p}{(}\PYG{n}{test4}\PYG{p}{,}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{test5}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{n}{IP\PYGZus{}list}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n}{not\PYGZus{}assigned}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{test5}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{not\PYGZus{}assigned}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{ip} \PYG{o+ow}{in} \PYG{n}{IP\PYGZus{}list}\PYG{p}{:}
                                \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{diff\PYGZus{}ip}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{mini} \PYG{p}{:}
                                        \PYG{n}{mini}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{diff\PYGZus{}ip}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                                        \PYG{n}{current}\PYG{o}{=}\PYG{n}{ip}
                        \PYG{n}{test5}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{current}
                        \PYG{k}{try}\PYG{p}{:}
                                \PYG{n}{IP\PYGZus{}list}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
                        \PYG{k}{except}\PYG{p}{:}
                                \PYG{k}{pass}
                \PYG{n}{mini}\PYG{o}{=}\PYG{l+m+mi}{12}
        \PYG{k}{return} \PYG{n}{test5}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Update\_history}
\label{\detokenize{OUP/Update_history:update-history}}\label{\detokenize{OUP/Update_history::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Update\PYGZus{}history}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{OUP/Update_history:definition}}
\sphinxAtStartPar
This is the main function of the algorithm used to update Origin History since log file.

\sphinxAtStartPar
This algorithm is ruled by followings steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting Users acount informations since the top level} : \sphinxstyleemphasis{Environnment variable getter}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Connecting an ssh session to the origin.srv\sphinxhyphen{}prive.icgm.fr server} : \sphinxstyleemphasis{Using netmiko module to automate authentified ssh session}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting raw users list Informations} : \sphinxstyleemphasis{From the output of the Origin Licence Request, Retrieve the connected users list}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting the Port Informations} : \sphinxstyleemphasis{From the} \sphinxstylestrong{netstat \sphinxhyphen{}anp} \sphinxstyleemphasis{command, retrieve the Origin server’s used port number}

\item {} 
\sphinxAtStartPar
** Getting the raw IP list informations** : \sphinxstyleemphasis{From the} \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t} \sphinxstyleemphasis{command, Dress the list of present IP in connexion table}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting the raw hostname list Informations} : \sphinxstyleemphasis{From the} \sphinxstylestrong{ss \sphinxhyphen{}n \sphinxhyphen{}t \sphinxhyphen{}r} \sphinxstyleemphasis{command, Get the hostname list preset in connexion table}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Exit the ssh session and read the Ordinateurs.ods file} : \sphinxstyleemphasis{From the Ordinateurs.ods file, Fid and store all the others needed informations as MAC @, Vlan Id, …}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Updating the Origin\_history file since the newest Informations}

\end{itemize}

\sphinxAtStartPar
The results are dispayed at screen but could be write in an Origin History


\subsection{Source}
\label{\detokenize{OUP/Update_history:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Update\PYGZus{}history}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{c+c1}{\PYGZsh{} Getting Users acount informations since the top level}

        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/known\PYGZus{}hosts}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{c+c1}{\PYGZsh{} Connecting an ssh session to the origin.srv\PYGZhy{}prive.icgm.fr server}

        \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Getting raw users list Informations}

        \PYG{n}{Users}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/lmutil  lmstat \PYGZhy{}a \PYGZhy{}c /opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/Licenses/Origin\PYGZus{}20jetons.lic | grep }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZca{}.*origin}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.srv\PYGZhy{}prive}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.icgm}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.fr/27000.*}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{User\PYGZus{}list}\PYG{o}{=}\PYG{n}{treat\PYGZus{}Users}\PYG{p}{(}\PYG{n}{Users}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{User\PYGZus{}list}\PYG{o}{==}\PYG{k+kc}{None}\PYG{p}{:}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{No users connected}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                \PYG{n}{quit}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Getting informations from the network Scan, Please to wait few minuts...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{User\PYGZus{}list}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Getting the Port Informations}

        \PYG{n}{Nb\PYGZus{}Port} \PYG{o}{=} \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{netstat \PYGZhy{}anp | grep }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{:::*}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{ | grep LISTEN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{Real\PYGZus{}port}\PYG{o}{=}\PYG{n}{get\PYGZus{}Port}\PYG{p}{(}\PYG{n}{Nb\PYGZus{}Port}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Real\PYGZus{}port}\PYG{p}{)}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{Real\PYGZus{}port} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{27000}\PYG{p}{)}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} Getting the raw IP list informations}

                \PYG{n}{IP}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ss \PYGZhy{}n \PYGZhy{}t | grep }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{Real\PYGZus{}port}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} | grep \PYGZhy{}Po \PYGZdq{}\PYGZbs{}K([0\PYGZhy{}9]*\PYGZbs{}.)\PYGZob{}3\PYGZcb{}[0\PYGZhy{}9]+\PYGZdq{}}
                \PYG{n}{IP\PYGZus{}list}\PYG{o}{=}\PYG{n}{get\PYGZus{}IP\PYGZus{}list}\PYG{p}{(}\PYG{n}{IP}\PYG{p}{)}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Getting the raw hostname list Informations}

                \PYG{n}{Host}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ss \PYGZhy{}n \PYGZhy{}t \PYGZhy{}r | grep }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{Real\PYGZus{}port}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{Host\PYGZus{}list}\PYG{o}{=}\PYG{n}{get\PYGZus{}Host\PYGZus{}list}\PYG{p}{(}\PYG{n}{Host}\PYG{p}{)}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Host\PYGZus{}list}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Exit the ssh session and read the Ordinateurs.ods file}

                \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
                \PYG{n}{Infos}\PYG{o}{=}\PYG{n}{Read\PYGZus{}ods}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../Ordinateurs.ods}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{Host\PYGZus{}list}\PYG{p}{,}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Updating the Origin\PYGZus{}history file since the newest Informations}

                \PYG{n}{User\PYGZus{}rep}\PYG{o}{=}\PYG{n}{get\PYGZus{}IP\PYGZus{}from\PYGZus{}log}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{User\PYGZus{}rep}\PYG{p}{)}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{n}{Treat\PYGZus{}Info}\PYG{p}{(}\PYG{n}{Infos}\PYG{p}{,}\PYG{n}{IPSwitchs}\PYG{p}{)}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{n}{get\PYGZus{}Description}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{)}
                \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{n}{get\PYGZus{}time}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{,}\PYG{n}{User\PYGZus{}rep}\PYG{p}{,}\PYG{n}{User\PYGZus{}list}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}write}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Get\_User\_Info\_From\_IP\_v2}
\label{\detokenize{Get_User_Info_From_IP_v2:get-user-info-from-ip-v2}}\label{\detokenize{Get_User_Info_From_IP_v2::doc}}
\sphinxAtStartPar
This script is the optimised version of the Origin\_Users.py script.

\sphinxAtStartPar
It uses the \sphinxstylestrong{Treat\_log\_v2.sh} file to get an immediate association between user ID and their IP.

\sphinxAtStartPar
Since the two first versions, the optimised version is ruled differently from the first one :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cut logfile} since the date (today as default)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Read and extract informations} from the logwatch file with the associated \sphinxstyleemphasis{Treat\_log\_v2.sh} Scripot

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Open, read \& Treat the logwatch} file :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting IP list} associated to a timed \& named token. The resultys are stored by time order, arbitrary indexed from 1 \sphinxhyphen{}\textgreater{} n

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting host ID} from the full Origin user name (with form \sphinxhref{mailto:name@host}{name@host}) =\textgreater{} Allow multiple users sessions on the same host

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Compute the Cantor difference} between two adjacents set (indexed +\sphinxhyphen{} 1) to get the User’s associated IP

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Building DHCP dictionnary} and get infos since the given IP adresses list as parameter :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Building DHCP Dictionnary}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Updating Users Dictionnary} since the DHCP dictionnary from the ip correspondance (as key entry of the Users dictionnary)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Updating the Users Dictionnary} since the Cisco output command : ssh \textless{}Cisco\_name\textgreater{} ‘show mac address’ to get the associated cisco switch ID and the gigabit ethernet ID

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Finaly write the RAM stored informations dictionnary} into the Origin\_history file

\end{itemize}

\sphinxAtStartPar
Please to use with the correct syntax :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 Get\PYGZus{}User\PYGZus{}Info\PYGZus{}From\PYGZus{}IP\PYGZus{}v3.py
\end{sphinxVerbatim}

\sphinxAtStartPar
The script must be used into an equivalent environment structure :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
.
├── DHCP
│   └── Get\PYGZus{}User\PYGZus{}Info\PYGZus{}From\PYGZus{}IP\PYGZus{}v3.py
└── dhcpd\PYGZhy{}vlan\PYGZus{}i.conf
└── dhcpd\PYGZhy{}vlan\PYGZus{}i+1.conf
.
.
.
└── dhcpd\PYGZhy{}vlan\PYGZus{}n.conf
\end{sphinxVerbatim}

\sphinxAtStartPar
The result is shown with the following syntax :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}mac\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}90b1.1ca3.3575\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}ip\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}10.14.18.145\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}hostname\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}\PYGZdq{}BBBAACCC\PYGZdq{}\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}departement\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}DPT4\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}vlan\PYGZsq{}}: \PYG{l+m}{513}, \PYG{l+s+s1}{\PYGZsq{}cisco\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}Balard\PYGZhy{}PAC\PYGZhy{}2\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}socket\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}1/0/36\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}Description\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}RJLG07\PYGZhy{}01\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}origin\PYGZus{}name\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}c2mstud@c2mstud3\PYGZhy{}pc\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}connexion time\PYGZsq{}}: \PYG{l+s+s1}{\PYGZsq{}198.3088238040606 min\PYGZsq{}}\PYG{o}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
With :


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Field Identifier}
&
\sphinxAtStartPar
\sphinxstylestrong{Data Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{mac}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Hexadecimal string}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The full mac address of the current User}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{ip}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Decimal string}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The full fixed IP from the origin server}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{hostname}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The Hostname from the DHCP server (could be different from the Origin server Hostname)}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{departement}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The departement description section}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{vlan}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Integer}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The sub\sphinxhyphen{}network lan Identifier}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{cisco}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The Cisco Switch Identifier Name}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{socket}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Decimal String}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The associated Gigabit Ethernet socket (with form **x/y/z*})*
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Description}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The associated outlet exact name (as it is written in a Cisco Switch)}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{origin\_name}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
\sphinxstyleemphasis{The Origin User’s avatar name}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{connexion time}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Float}
&
\sphinxAtStartPar
\sphinxstyleemphasis{If still connected, the connection time of the User, else the starting connection time}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Finally written into the Origin\_history file into the \sphinxstylestrong{origin.srv\sphinxhyphen{}prive.icgm.fr} server.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{re}
\PYG{k+kn}{import} \PYG{n+nn}{datetime} \PYG{k}{as} \PYG{n+nn}{dt}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{import} \PYG{n+nn}{netmiko}
\PYG{k+kn}{from} \PYG{n+nn}{multiprocessing} \PYG{k+kn}{import} \PYG{n}{Process}

\PYG{n}{\PYGZus{}\PYGZus{}author\PYGZus{}\PYGZus{}}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CABOS Matthieu}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{\PYGZus{}\PYGZus{}date\PYGZus{}\PYGZus{}}\PYG{o}{=}\PYG{l+m+mi}{21}\PYG{o}{/}\PYG{l+m+mi}{12}\PYG{o}{/}\PYG{l+m+mi}{2021}

\PYG{n}{IPSwitchs}\PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}1C\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.47}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}1D\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.49}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}1G\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.51}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}1H\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.54}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}2C\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.56}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}2D\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.58}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}2G\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.60}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}2H\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.62}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}2H\PYGZhy{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.63}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}3C\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.65}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}3D\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.67}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}3G\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.69}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}3G\PYGZhy{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.70}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}3H\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.72}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}4C\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.74}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}4D\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.76}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}4G\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.78}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}4H\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.80}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}EP\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.40}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}PAC\PYGZhy{}1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.42}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Balard\PYGZhy{}PAC\PYGZhy{}2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.0.43}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Vlans}\PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{501}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IDRAC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{510}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DPT1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{511}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DPT2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{512}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DPT3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{513}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DPT4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{514}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DPT5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{515}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSTRU\PYGZhy{}ON}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{516}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSTRU\PYGZhy{}OFF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{518}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IMPRIM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{519}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GUEST}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{524}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SGAF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{525}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SSI}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{526}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ExpProtect}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{528}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IDRAC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{529}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Did}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{l+m+mi}{530}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PT}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} IP\PYGZus{}list=sys.argv[1]}

\PYG{n}{Time\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{IP\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.23.214}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.18.135}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}\PYG{p}{:}

  \PYG{c+c1}{\PYGZsh{} Split Dictionnary into div differents dictionnary}

  \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
  \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{)}\PYG{o}{/}\PYG{n}{div}\PYG{p}{)}\PYG{p}{)}

  \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Cisco\PYGZus{}Dic}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{tmp}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}
    \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{ind}\PYG{o}{==}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
      \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
      \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{res}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{res}

\PYG{n}{List\PYGZus{}Dic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{List\PYGZus{}Dic}\PYG{o}{=}\PYG{n}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{p}{,}\PYG{l+m+mi}{21}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{Del\PYGZus{}Duplicate}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{verif}\PYG{o}{=}\PYG{n}{liste}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
  \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{liste}\PYG{p}{:}
    \PYG{n}{verif}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{verif}\PYG{p}{:}
      \PYG{n}{liste}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{liste}

\PYG{k}{def} \PYG{n+nf}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{command}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/cisco}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco\PYGZus{}ios}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{n}{IPSwitchs}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
  \PYG{n}{Output}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}
  \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{Output}

\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Users\PYGZus{}Info}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}

  \PYG{c+c1}{\PYGZsh{} Building DHCP dictionnary and get infos since the given IP adresses list as parameter}

  \PYG{c+c1}{\PYGZsh{} Variable Initialisation}

  \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{Users}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
  \PYG{n}{Users\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{DHCP\PYGZus{}Dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{Content}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{socket}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{0}


  \PYG{c+c1}{\PYGZsh{} Regular Expressions Definition}

  \PYG{n}{regex\PYGZus{}MAC}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9A\PYGZhy{}Fa\PYGZhy{}f]}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:)}\PYG{l+s+si}{\PYGZob{}5\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9A\PYGZhy{}Fa\PYGZhy{}f]}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}IP}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fixed.*}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}raw\PYGZus{}ip}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}hostname}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZhy{}\PYGZus{}]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}cisco}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gi([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{/)}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}description}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[NRJPASEP]+[0\PYGZhy{}9]+[A\PYGZhy{}K][0\PYGZhy{}9]+\PYGZhy{}[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

  \PYG{c+c1}{\PYGZsh{} Building DHCP Dictionnary}

  \PYG{k}{for} \PYG{n}{vlan} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Vlans}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../dhcpd\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{vlan}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.conf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{Content}\PYG{o}{=}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Content}\PYG{p}{:}
      \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}MAC}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
      \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{:}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{]}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{]}
      \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}IP}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
      \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{matches2}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}raw\PYGZus{}ip}\PYG{p}{,} \PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{mn}\PYG{p}{,} \PYG{n}{mat} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches2}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
          \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{mat}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
      \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}hostname}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
      \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hostname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
      \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{departement}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{Vlans}\PYG{p}{[}\PYG{n}{vlan}\PYG{p}{]}
      \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vlan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vlan}
      \PYG{k}{if} \PYG{n}{tmp\PYGZus{}dict} \PYG{o}{!=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{:}
        \PYG{n}{Users}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}dict}\PYG{p}{)}
      \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{DHCP\PYGZus{}Dict}\PYG{p}{[}\PYG{n}{Vlans}\PYG{p}{[}\PYG{n}{vlan}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{n}{Del\PYGZus{}Duplicate}\PYG{p}{(}\PYG{n}{Users}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{Users}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

  \PYG{c+c1}{\PYGZsh{} Updating Users Dictionnary since the DHCP dictionnary from the ip correspondance (as key entry of the Users dictionnary)}

  \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{DHCP\PYGZus{}Dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{v}\PYG{p}{:}
      \PYG{k}{for} \PYG{n}{ip} \PYG{o+ow}{in} \PYG{n}{IP\PYGZus{}list}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{item}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{ip}\PYG{p}{:}
          \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{=}\PYG{n}{item}

  \PYG{c+c1}{\PYGZsh{} Updating the Users Dictionnary since the Cisco output command : ssh \PYGZlt{}Cisco\PYGZus{}name\PYGZgt{} \PYGZsq{}show mac address\PYGZsq{} to get the associated cisco switch ID and the gigabit ethernet ID}

  \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{Process\PYGZus{}List}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
  \PYG{k}{for} \PYG{n}{cisco} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} //}
    \PYG{c+c1}{\PYGZsh{} print(IPSwitchs[cisco])}
    \PYG{c+c1}{\PYGZsh{} print(List\PYGZus{}Dic[i])}
    \PYG{n}{i}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
    \PYG{k}{try}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{} HERE !!!}
      \PYG{n}{Content}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sh mac address}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{k}{except}\PYG{p}{:}
      \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cisco}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ is not avaible at the moment}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{ContList}\PYG{o}{=}\PYG{n}{Content}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{user} \PYG{o+ow}{in} \PYG{n}{Users\PYGZus{}dict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{ContList}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{user}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
          \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{user}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{cisco}
          \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}cisco}\PYG{p}{,} \PYG{n}{line}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
          \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{socket}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
          \PYG{k}{if} \PYG{n}{socket}\PYG{o}{!=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
            \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{user}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{socket}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{socket}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}
            \PYG{n}{count}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
            \PYG{n}{socket}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{count}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Users\PYGZus{}dict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{break}

  \PYG{n}{Content}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Users\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} //}
    \PYG{k}{try}\PYG{p}{:}
      \PYG{c+c1}{\PYGZsh{} HERE !!!}
      \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
      \PYG{n}{Content}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sh int gigabitethernet }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{socket}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
      \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Informations missing about user}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}description}\PYG{p}{,} \PYG{n}{Content}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Description}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{Users\PYGZus{}dict}

\PYG{k}{def} \PYG{n+nf}{Cut\PYGZus{}log}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

  \PYG{c+c1}{\PYGZsh{} Cut logfile since the date (today as default)}

  \PYG{k}{try}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp mcabos@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}/logwatch .}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{except}\PYG{p}{:}
    \PYG{k}{pass}

  \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{date}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{Content}\PYG{o}{=}\PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{False}
  \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

  \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{Content}\PYG{p}{:}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{date}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{)} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{Keep\PYGZus{}flag}\PYG{p}{:}
      \PYG{n}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{True}
    \PYG{k}{if} \PYG{n}{Keep\PYGZus{}flag}\PYG{p}{:}
      \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
  \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}write}\PYG{p}{:}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
  \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{time\PYGZus{}to\PYGZus{}timestamp}\PYG{p}{(}\PYG{n}{str\PYGZus{}time}\PYG{p}{)}\PYG{p}{:}

  \PYG{c+c1}{\PYGZsh{} Get timestamp from the given string date}

  \PYG{c+c1}{\PYGZsh{} Regular Expressions definition}

  \PYG{n}{regex\PYGZus{}time}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}month}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[a\PYGZhy{}zéè]+}\PYG{l+s+s1}{\PYGZsq{}}

  \PYG{c+c1}{\PYGZsh{} Variable definition}

  \PYG{n}{year}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{month}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{day}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{hour}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{minuts}\PYG{o}{=}\PYG{l+m+mi}{0}

  \PYG{c+c1}{\PYGZsh{} Getting integer fields since conversion}

  \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}time}\PYG{p}{,}\PYG{n}{str\PYGZus{}time}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
      \PYG{n}{day}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{2} \PYG{p}{:}
      \PYG{n}{hour}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{3} \PYG{p}{:}
      \PYG{n}{minuts}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{5} \PYG{p}{:}
      \PYG{n}{year}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}month}\PYG{p}{,} \PYG{n}{str\PYGZus{}time}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
  \PYG{n}{month}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date +}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{m}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{date}\PYG{o}{=}\PYG{n}{dt}\PYG{o}{.}\PYG{n}{datetime}\PYG{p}{(}\PYG{l+m+mi}{2021}\PYG{p}{,}\PYG{n}{month}\PYG{p}{,}\PYG{n}{day}\PYG{p}{,}\PYG{n}{hour}\PYG{p}{,}\PYG{n}{minuts}\PYG{p}{)}
  \PYG{n}{timestamp}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{mktime}\PYG{p}{(}\PYG{n}{date}\PYG{o}{.}\PYG{n}{timetuple}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Return the equivalent timestamp (in seconds since epoch)}

  \PYG{k}{return}\PYG{p}{(}\PYG{n}{timestamp}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{Read\PYGZus{}and\PYGZus{}treat\PYGZus{}log}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}

  \PYG{c+c1}{\PYGZsh{} Read and extract informations from the logwatch file}

  \PYG{c+c1}{\PYGZsh{} Regular Expression Definition}

  \PYG{n}{regex\PYGZus{}date}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[a\PYGZhy{}z]+([\PYGZca{}a\PYGZhy{}z]+.*[0\PYGZhy{}9]*}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{n)+}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}ip}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)+[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}name}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{OriginPro}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{.*}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}pc}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{@.*}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{regex\PYGZus{}time}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZca{}[a\PYGZhy{}z].*}\PYG{l+s+s1}{\PYGZsq{}}

  \PYG{c+c1}{\PYGZsh{} Variables Definition}

  \PYG{n}{banned}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
  \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{ip\PYGZus{}set}\PYG{o}{=}\PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{find\PYGZus{}ip\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{time\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{diff}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{0}
  \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{\PYGZsh{} Open and read the logwatch file}

  \PYG{n}{Cut\PYGZus{}log}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{Content}\PYG{o}{=}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{match\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

  \PYG{c+c1}{\PYGZsh{} 1/ Getting IP list associated to a timed \PYGZam{} named token. The resultys are stored by time order, arbitrary indexed from 1 \PYGZhy{}\PYGZgt{} n}

  \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}date}\PYG{p}{,} \PYG{n}{Content}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{match\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{match\PYGZus{}list}\PYG{p}{:}
    \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}ip}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{banned}\PYG{p}{:}
        \PYG{n}{ip\PYGZus{}set}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}name}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{name}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{:}\PYG{p}{]}
    \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}\PYG{o}{=}\PYG{n}{ip\PYGZus{}set}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{name} \PYG{o}{!=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o+ow}{and} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ip\PYGZus{}set}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{0}\PYG{p}{:}
      \PYG{n}{find\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{count}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{n}{tmp\PYGZus{}dict}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
      \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}time}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
      \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,}\PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{time\PYGZus{}dict}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{count}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{n}{time\PYGZus{}to\PYGZus{}timestamp}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ip\PYGZus{}set}\PYG{o}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{count}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}

  \PYG{c+c1}{\PYGZsh{} 2/ Getting host ID from the full Origin user name (with form name@host) =\PYGZgt{} Allow multiple users sessions on the same host}

  \PYG{n}{TEMP}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{find\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{find\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{TEMP}\PYG{p}{:}
      \PYG{n}{Time\PYGZus{}dict}\PYG{p}{[}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{find\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{n}{time\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
    \PYG{n}{TEMP}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{find\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}pc}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{v}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{host}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
      \PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{host}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{v}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}

      \PYG{c+c1}{\PYGZsh{} 3/ Compute the Cantor difference between two adjacents set (indexed +\PYGZhy{} 1) to get the User\PYGZsq{}s associated IP}

      \PYG{n}{diff}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{v}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}
      \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{diff}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{p}{[}\PYG{n}{host}\PYG{p}{]}\PYG{o}{=}\PYG{n}{diff}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{tmp}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{v}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{name\PYGZus{}ip\PYGZus{}dict}

\PYG{k}{def} \PYG{n+nf}{Write\PYGZus{}in\PYGZus{}file}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{,}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}

  \PYG{c+c1}{\PYGZsh{} Write Infos in file}

  \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Connected}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

  \PYG{c+c1}{\PYGZsh{} Get connected user list since the orgin token licence}

  \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/known\PYGZus{}hosts}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{n}{ssh\PYGZus{}origin} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
  \PYG{n}{Connected}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}origin}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/lmutil  lmstat \PYGZhy{}a \PYGZhy{}c /opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/Licenses/Origin\PYGZus{}20jetons.lic | grep }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZca{}.*origin}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.srv\PYGZhy{}prive}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.icgm}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.fr/27000.*}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{ssh\PYGZus{}origin}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}

  \PYG{n}{regex\PYGZus{}cnctd}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZhy{}[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Connected}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}cnctd}\PYG{p}{,} \PYG{n}{Connected}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{Connected}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
      \PYG{k}{break}
  \PYG{k}{return}\PYG{p}{(}\PYG{n}{Connected}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Main Users Informations Finder Algorithm}

\PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{o}{=}\PYG{n}{Read\PYGZus{}and\PYGZus{}treat\PYGZus{}log}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{IP\PYGZus{}list}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Users\PYGZus{}dict}\PYG{o}{=}\PYG{n}{Get\PYGZus{}Users\PYGZus{}Info}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}
\PYG{n}{Connected}\PYG{o}{=}\PYG{n}{get\PYGZus{}Connected}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Users\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{if} \PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{position}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{origin\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{name\PYGZus{}ip\PYGZus{}dict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n}{position}\PYG{p}{]}
  \PYG{k}{for} \PYG{n}{l}\PYG{p}{,}\PYG{n}{m} \PYG{o+ow}{in} \PYG{n}{Time\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{origin\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{l}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{origin\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{Connected}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{connexion time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{p}{)}
        \PYG{k}{break}
      \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{connexion time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{not avaible, start at }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:}
      \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error occured, user is not present into log archive.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
      \PYG{k}{break}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}

\PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{try}\PYG{p}{:}
  \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:/home/mcabos/Origin\PYGZus{}history .}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
  \PYG{k}{pass}
\PYG{n}{Write\PYGZus{}in\PYGZus{}file}\PYG{p}{(}\PYG{n}{Users\PYGZus{}dict}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./Origin\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp ./Origin\PYGZus{}history }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{user}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{@origin.srv\PYGZhy{}prive.icgm.fr:/home/mcabos/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Get\_User\_Info\_From\_IP\_v2\_API}
\label{\detokenize{Get_User_Info_From_IP_v2_API:get-user-info-from-ip-v2-api}}\label{\detokenize{Get_User_Info_From_IP_v2_API::doc}}
\sphinxAtStartPar
Here you will find all the associated functions to the Get\_User\_Info\_From\_IP\_v2\_API version.

\sphinxstepscope

\newpage
\section{cut\_dic}
\label{\detokenize{GUIFI/cut_dic:cut-dic}}\label{\detokenize{GUIFI/cut_dic::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/cut_dic:definition}}
\sphinxAtStartPar
Split Dictionnary into div differents dictionnary.
Useful function for parallelism section.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Cisco\_Dic}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Dictionnary}
&
\sphinxAtStartPar
The dictionnary containing all the Cisco name:IP address informations
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{div}
&
\sphinxAtStartPar
\sphinxstyleemphasis{Integer}
&
\sphinxAtStartPar
The number of slice to get
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{GUIFI/cut_dic:returns}}
\sphinxAtStartPar
List of Dictionnaries
The List of Sliced dictionnaries


\subsection{Source}
\label{\detokenize{GUIFI/cut_dic:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cut\PYGZus{}dic}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}\PYG{p}{:}

        \PYG{c+c1}{\PYGZsh{} Split Dictionnary into div differents dictionnary}

        \PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Cisco\PYGZus{}Dic}\PYG{p}{)}\PYG{o}{/}\PYG{n}{div}\PYG{p}{)}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Cisco\PYGZus{}Dic}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}
                \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{ind}\PYG{o}{==}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
                        \PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Del\_Duplicate}
\label{\detokenize{GUIFI/Del_Duplicate:del-duplicate}}\label{\detokenize{GUIFI/Del_Duplicate::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Del\PYGZus{}Duplicate}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/Del_Duplicate:definition}}
\sphinxAtStartPar
Utilitary function removing all the duplicated values of the given list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{List}
&
\sphinxAtStartPar
The list to treat
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{GUIFI/Del_Duplicate:returns}}
\sphinxAtStartPar
List
The same list without duplicated values


\subsection{Source}
\label{\detokenize{GUIFI/Del_Duplicate:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Del\PYGZus{}Duplicate}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{verif}\PYG{o}{=}\PYG{n}{liste}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{liste}\PYG{p}{:}
                \PYG{n}{verif}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
                \PYG{k}{if} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{verif}\PYG{p}{:}
                        \PYG{n}{liste}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{liste}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{ssh\_session}
\label{\detokenize{GUIFI/ssh_session:ssh-session}}\label{\detokenize{GUIFI/ssh_session::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{command}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/ssh_session:definition}}
\sphinxAtStartPar
Treat a ssh remote command session. Automate the authentified ssh connexion and restitute the remote command output


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{cisco}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The cisco switch name to connect
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{command}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The command list as a string list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{GUIFI/ssh_session:returns}}
\sphinxAtStartPar
String
The remote command output


\subsection{Source}
\label{\detokenize{GUIFI/ssh_session:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{n}{command}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/cisco}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{ssh\PYGZus{}session} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco\PYGZus{}ios}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{n}{IPSwitchs}\PYG{p}{[}\PYG{n}{cisco}\PYG{p}{]}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
        \PYG{n}{Output}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}
        \PYG{n}{ssh\PYGZus{}session}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Output}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Get\_Users\_Info}
\label{\detokenize{GUIFI/Get_Users_Info:get-users-info}}\label{\detokenize{GUIFI/Get_Users_Info::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Users\PYGZus{}Info}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/Get_Users_Info:definition}}
\sphinxAtStartPar
Building DHCP dictionnary and get infos since the given IP adresses list as parameter.

\sphinxAtStartPar
To do so, the DHCP dictionnary construction obey to the following looped instructions :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Define the following regular expressions} to retrieve the differents fields from the DHCP configuration files :
\begin{itemize}
\item {} 
\sphinxAtStartPar
MAC address : \sphinxstylestrong{({[}0\sphinxhyphen{}9A\sphinxhyphen{}Fa\sphinxhyphen{}f{]}\{2\}\textbackslash{}:)\{5\}{[}0\sphinxhyphen{}9A\sphinxhyphen{}Fa\sphinxhyphen{}f{]}\{2\}}

\item {} 
\sphinxAtStartPar
IP address : \sphinxstylestrong{fixed.*}

\item {} 
\sphinxAtStartPar
Raw ip : \sphinxstylestrong{({[}0\sphinxhyphen{}9{]}+\textbackslash{}.)\{3\}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
Hostname : \sphinxstylestrong{\textbackslash{}”{[}A\sphinxhyphen{}Za\sphinxhyphen{}z0\sphinxhyphen{}9\sphinxhyphen{}\_{]}+\textbackslash{}”}

\item {} 
\sphinxAtStartPar
Cisco name : \sphinxstylestrong{Gi({[}0\sphinxhyphen{}9{]}+\textbackslash{}/)\{2\}{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
Outlet Description : \sphinxstylestrong{{[}NRJPASEP{]}+{[}0\sphinxhyphen{}9{]}+{[}A\sphinxhyphen{}K{]}{[}0\sphinxhyphen{}9{]}+\sphinxhyphen{}{[}0\sphinxhyphen{}9{]}+}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{For each vlan present on the network} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Read the associated dhcps\sphinxhyphen{}vlanId.conf file}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{For each slice of the file} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Get informations since the regular expressions filtering}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Store them into the tmp\_dict dictionnary}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Append the dictionnary to the Users list}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Delete duplicated values} from the Users list if necessary

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Store the Users list into the DHCP\_Dict dictionnary} (sorted by Vlan name)

\end{itemize}

\end{itemize}

\sphinxAtStartPar
The main algorithm used to link informations together is ruled by the followings steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Regular Expressions Definition}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Building DHCP Dictionnary}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Updating Users Dictionnary since the DHCP dictionnary} \sphinxstyleemphasis{from the ip correspondance (as key entry of the Users dictionnary)}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Updating the Users Dictionnary since the Cisco output command} : \sphinxstylestrong{ssh \textless{}Cisco\_name\textgreater{} ‘show mac address’} \sphinxstyleemphasis{to get the associated cisco switch ID and the gigabit ethernet ID}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{IP\_list}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The ip address list to treat as input (corresponding to the connected users list)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{GUIFI/Get_Users_Info:returns}}
\sphinxAtStartPar
Dictionnary
The Users Dictionnary repertoring all the needed informations from the DHCP configuration files.


\subsection{Source}
\label{\detokenize{GUIFI/Get_Users_Info:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Get\PYGZus{}Users\PYGZus{}Info}\PYG{p}{(}\PYG{n}{IP\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}

        \PYG{c+c1}{\PYGZsh{} Building DHCP dictionnary and get infos since the given IP adresses list as parameter}

        \PYG{c+c1}{\PYGZsh{} Variable Initialisation}

        \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{Users}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{Users\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{DHCP\PYGZus{}Dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n}{Content}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{socket}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{0}


        \PYG{c+c1}{\PYGZsh{} Regular Expressions Definition}

        \PYG{n}{regex\PYGZus{}MAC}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9A\PYGZhy{}Fa\PYGZhy{}f]}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{:)}\PYG{l+s+si}{\PYGZob{}5\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9A\PYGZhy{}Fa\PYGZhy{}f]}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}IP}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fixed.*}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}raw\PYGZus{}ip}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.)}\PYG{l+s+si}{\PYGZob{}3\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}hostname}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9\PYGZhy{}\PYGZus{}]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}cisco}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Gi([0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{/)}\PYG{l+s+si}{\PYGZob{}2\PYGZcb{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}description}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[NRJPASEP]+[0\PYGZhy{}9]+[A\PYGZhy{}K][0\PYGZhy{}9]+\PYGZhy{}[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{c+c1}{\PYGZsh{} Building DHCP Dictionnary}

        \PYG{k}{for} \PYG{n}{vlan} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{Vlans}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../dhcpd\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{vlan}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.conf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{n}{Content}\PYG{o}{=}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{Content}\PYG{p}{:}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}MAC}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{tmp}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                                \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{:}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{]}\PYG{o}{+}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{]}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}IP}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{matches2}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}raw\PYGZus{}ip}\PYG{p}{,} \PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                                \PYG{k}{for} \PYG{n}{mn}\PYG{p}{,} \PYG{n}{mat} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches2}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{mat}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}hostname}\PYG{p}{,} \PYG{n}{item}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hostname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                        \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{departement}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{Vlans}\PYG{p}{[}\PYG{n}{vlan}\PYG{p}{]}
                        \PYG{n}{tmp\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{vlan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vlan}
                        \PYG{k}{if} \PYG{n}{tmp\PYGZus{}dict} \PYG{o}{!=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{:}
                                \PYG{n}{Users}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}dict}\PYG{p}{)}
                        \PYG{n}{tmp\PYGZus{}dict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
                \PYG{n}{DHCP\PYGZus{}Dict}\PYG{p}{[}\PYG{n}{Vlans}\PYG{p}{[}\PYG{n}{vlan}\PYG{p}{]}\PYG{p}{]}\PYG{o}{=}\PYG{n}{Del\PYGZus{}Duplicate}\PYG{p}{(}\PYG{n}{Users}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
                \PYG{n}{Users}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

        \PYG{c+c1}{\PYGZsh{} Updating Users Dictionnary since the DHCP dictionnary from the ip correspondance (as key entry of the Users dictionnary)}

        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{DHCP\PYGZus{}Dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{v}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{ip} \PYG{o+ow}{in} \PYG{n}{IP\PYGZus{}list}\PYG{p}{:}
                                \PYG{k}{if} \PYG{n}{item}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{ip}\PYG{p}{:}
                                        \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{ip}\PYG{p}{]}\PYG{o}{=}\PYG{n}{item}

        \PYG{c+c1}{\PYGZsh{} Updating the Users Dictionnary since the Cisco output command : ssh \PYGZlt{}Cisco\PYGZus{}name\PYGZgt{} \PYGZsq{}show mac address\PYGZsq{} to get the associated cisco switch ID and the gigabit ethernet ID}

        \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{Process\PYGZus{}List}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{cisco} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{IPSwitchs}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} //}
                \PYG{c+c1}{\PYGZsh{} print(IPSwitchs[cisco])}
                \PYG{c+c1}{\PYGZsh{} print(List\PYGZus{}Dic[i])}
                \PYG{n}{i}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{c+c1}{\PYGZsh{} HERE !!!}
                        \PYG{n}{Content}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{cisco}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sh mac address}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cisco}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ is not avaible at the moment}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

                \PYG{n}{ContList}\PYG{o}{=}\PYG{n}{Content}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{user} \PYG{o+ow}{in} \PYG{n}{Users\PYGZus{}dict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{ContList}\PYG{p}{:}
                                \PYG{k}{if} \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{user}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mac}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
                                        \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{user}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{cisco}
                                        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}cisco}\PYG{p}{,} \PYG{n}{line}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                                        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{socket}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
                                        \PYG{k}{if} \PYG{n}{socket}\PYG{o}{!=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
                                                \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{user}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{socket}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{socket}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}
                                                \PYG{n}{count}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                                                \PYG{n}{socket}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{k}{if} \PYG{n}{count}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Users\PYGZus{}dict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{break}

        \PYG{n}{Content}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{Users\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} //}
                \PYG{k}{try}\PYG{p}{:}
                        \PYG{c+c1}{\PYGZsh{} HERE !!!}
                        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                        \PYG{n}{Content}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}session}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cisco}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sh int gigabitethernet }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{v}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{socket}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{except}\PYG{p}{:}
                        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Informations missing about user}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}

                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}description}\PYG{p}{,} \PYG{n}{Content}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{Users\PYGZus{}dict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Description}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{Users\PYGZus{}dict}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Cut\_log}
\label{\detokenize{GUIFI/Cut_log:cut-log}}\label{\detokenize{GUIFI/Cut_log::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Cut\PYGZus{}log}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/Cut_log:definition}}
\sphinxAtStartPar
Cut logfile since the date (today as default) and write it in the local folder

\sphinxAtStartPar
This function cut the logwatch file since the current date and restitute the content until the end of file.


\subsection{Source}
\label{\detokenize{GUIFI/Cut_log:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Cut\PYGZus{}log}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{c+c1}{\PYGZsh{} Cut logfile since the date (today as default)}

        \PYG{k}{try}\PYG{p}{:}
                \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scp mcabos@origin.srv\PYGZhy{}prive.icgm.fr:\PYGZti{}/logwatch .}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{except}\PYG{p}{:}
                \PYG{k}{pass}

        \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{date}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{Content}\PYG{o}{=}\PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{False}
        \PYG{n}{to\PYGZus{}write}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

        \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{Content}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{date}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{)} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{Keep\PYGZus{}flag}\PYG{p}{:}
                        \PYG{n}{Keep\PYGZus{}flag}\PYG{o}{=}\PYG{k+kc}{True}
                \PYG{k}{if} \PYG{n}{Keep\PYGZus{}flag}\PYG{p}{:}
                        \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./logwatch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}write}\PYG{p}{:}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{time\_to\_timestamp}
\label{\detokenize{GUIFI/time_to_timestamp:time-to-timestamp}}\label{\detokenize{GUIFI/time_to_timestamp::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{time\PYGZus{}to\PYGZus{}timestamp}\PYG{p}{(}\PYG{n}{str\PYGZus{}time}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/time_to_timestamp:definition}}
\sphinxAtStartPar
Utilitary converter function getting timestamp from the given string date.
It uses regular expressions filtering to get time and month field.
The timestamp is generated since the retrieved informations passed as parameters of the \sphinxstylestrong{time.mktime()} command.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{str\_time}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The date\sphinxhyphen{}time formated as String
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{GUIFI/time_to_timestamp:returns}}
\sphinxAtStartPar
Integer
The correct converted timestamp


\subsection{Source}
\label{\detokenize{GUIFI/time_to_timestamp:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{time\PYGZus{}to\PYGZus{}timestamp}\PYG{p}{(}\PYG{n}{str\PYGZus{}time}\PYG{p}{)}\PYG{p}{:}

        \PYG{c+c1}{\PYGZsh{} Get timestamp from the given string date}

        \PYG{c+c1}{\PYGZsh{} Regular Expressions definition}

        \PYG{n}{regex\PYGZus{}time}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{regex\PYGZus{}month}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[a\PYGZhy{}zéè]+}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{c+c1}{\PYGZsh{} Variable definition}

        \PYG{n}{year}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{month}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{day}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{hour}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{minuts}\PYG{o}{=}\PYG{l+m+mi}{0}

        \PYG{c+c1}{\PYGZsh{} Getting integer fields since conversion}

        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}time}\PYG{p}{,}\PYG{n}{str\PYGZus{}time}\PYG{p}{,}\PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                        \PYG{n}{day}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{elif} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{2} \PYG{p}{:}
                        \PYG{n}{hour}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{elif} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{3} \PYG{p}{:}
                        \PYG{n}{minuts}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{elif} \PYG{n}{matchNum} \PYG{o}{==} \PYG{l+m+mi}{5} \PYG{p}{:}
                        \PYG{n}{year}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}month}\PYG{p}{,} \PYG{n}{str\PYGZus{}time}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
        \PYG{n}{month}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{popen}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{date +}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{m}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{date}\PYG{o}{=}\PYG{n}{dt}\PYG{o}{.}\PYG{n}{datetime}\PYG{p}{(}\PYG{l+m+mi}{2021}\PYG{p}{,}\PYG{n}{month}\PYG{p}{,}\PYG{n}{day}\PYG{p}{,}\PYG{n}{hour}\PYG{p}{,}\PYG{n}{minuts}\PYG{p}{)}
        \PYG{n}{timestamp}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{mktime}\PYG{p}{(}\PYG{n}{date}\PYG{o}{.}\PYG{n}{timetuple}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Return the equivalent timestamp (in seconds since epoch)}

        \PYG{k}{return}\PYG{p}{(}\PYG{n}{timestamp}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{Read\_and\_treat\_log}
\label{\detokenize{GUIFI/Read_and_treat_log:read-and-treat-log}}\label{\detokenize{GUIFI/Read_and_treat_log::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Read\PYGZus{}and\PYGZus{}treat\PYGZus{}log}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/Read_and_treat_log:definition}}
\sphinxAtStartPar
This function make the association between a Origin user name and its own Ip address.
Read and extract the following informations from the logwatch file using regular expressions :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Date : \sphinxstylestrong{{[}a\sphinxhyphen{}z{]}+({[}\textasciicircum{}a\sphinxhyphen{}z{]}+.*{[}0\sphinxhyphen{}9{]}*\textbackslash{}n)+}

\item {} 
\sphinxAtStartPar
IP : \sphinxstylestrong{({[}0\sphinxhyphen{}9{]}+\textbackslash{}.)+{[}0\sphinxhyphen{}9{]}+}

\item {} 
\sphinxAtStartPar
Name : \sphinxstylestrong{\textbackslash{}”OriginPro\textbackslash{}”.}

\item {} 
\sphinxAtStartPar
PC : \sphinxstylestrong{\textbackslash{}@.*}

\item {} 
\sphinxAtStartPar
Time : \sphinxstylestrong{\textasciicircum{}{[}a\sphinxhyphen{}z{]}.*}

\end{itemize}

\sphinxAtStartPar
To get informations from the logwatch file, the algorithm is ruled by instructions :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Regular Expression Definition}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Variables Definition}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Open and read the logwatch file}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting IP list associated to a timed \& named token.} The results are stored by time order, arbitrary indexed from 1 \sphinxhyphen{}\textgreater{} n

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting host ID from the full Origin user name} (with form \sphinxhref{mailto:name@host}{name@host}) =\textgreater{} Allow multiple users sessions on the same host

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Compute the Set difference between two adjacents Ip set} (indexed +\sphinxhyphen{} 1) to get the User’s associated IP

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{path}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The path to the logwatch file to read
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Returns}
\label{\detokenize{GUIFI/Read_and_treat_log:returns}}
\sphinxAtStartPar
Dictionnary
The name\_ip\_dict dictionnary associating to an Origin user name its own ip address


\subsection{Source}
\label{\detokenize{GUIFI/Read_and_treat_log:source}}
\sphinxstepscope

\newpage
\section{Write\_in\_file}
\label{\detokenize{GUIFI/Write_in_file:write-in-file}}\label{\detokenize{GUIFI/Write_in_file::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Write\PYGZus{}in\PYGZus{}file}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{,}\PYG{n}{path}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/Write_in_file:definition}}
\sphinxAtStartPar
Write Infos in file in append mode : if file already exists, the content is added from the end.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{to\_write}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String List}
&
\sphinxAtStartPar
The content to write as String List to write line by line
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{path}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The path where the file must be written
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Source}
\label{\detokenize{GUIFI/Write_in_file:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{Write\PYGZus{}in\PYGZus{}file}\PYG{p}{(}\PYG{n}{to\PYGZus{}write}\PYG{p}{,}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}

        \PYG{c+c1}{\PYGZsh{} Write Infos in file}

        \PYG{n}{f}\PYG{o}{=}\PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{to\PYGZus{}write}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope

\newpage
\section{get\_Connected}
\label{\detokenize{GUIFI/get_Connected:get-connected}}\label{\detokenize{GUIFI/get_Connected::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Connected}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{Definition}
\label{\detokenize{GUIFI/get_Connected:definition}}
\sphinxAtStartPar
Get connected user list since the orgin token licence.
The function read the Licence manager from Origin and extract the connected users name list.
This function use regular expression matching to get user name from the ssh remote command output :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/lmutil  lmstat \PYGZhy{}a \PYGZhy{}c /opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/Licenses/Origin\PYGZus{}20jetons.lic \PYG{p}{|} grep \PYG{l+s+s2}{\PYGZdq{}\PYGZca{}.*origin\PYGZbs{}.srv\PYGZhy{}prive\PYGZbs{}.icgm\PYGZbs{}.fr/27000.*\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Returns}
\label{\detokenize{GUIFI/get_Connected:returns}}
\sphinxAtStartPar
String List
The list containing all the Origin connected hostnames


\subsection{Source}
\label{\detokenize{GUIFI/get_Connected:source}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}Connected}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{c+c1}{\PYGZsh{} Get connected user list since the orgin token licence}

        \PYG{n}{home}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{HOME}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{user}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getenv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{USER}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{keyfile}\PYG{o}{=}\PYG{n}{home}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/.ssh/known\PYGZus{}hosts}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{ssh\PYGZus{}origin} \PYG{o}{=} \PYG{n}{netmiko}\PYG{o}{.}\PYG{n}{ConnectHandler}\PYG{p}{(}\PYG{n}{device\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ip}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10.14.14.20}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{use\PYGZus{}keys}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{key\PYGZus{}file}\PYG{o}{=}\PYG{n}{keyfile}\PYG{p}{)}
        \PYG{n}{Connected}\PYG{o}{=}\PYG{n}{ssh\PYGZus{}origin}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/lmutil  lmstat \PYGZhy{}a \PYGZhy{}c /opt/Linux\PYGZus{}FLEXnet\PYGZus{}Server\PYGZus{}ver\PYGZus{}11.16.5.1/Licenses/Origin\PYGZus{}20jetons.lic | grep }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZca{}.*origin}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.srv\PYGZhy{}prive}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.icgm}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{.fr/27000.*}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ssh\PYGZus{}origin}\PYG{o}{.}\PYG{n}{disconnect}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{regex\PYGZus{}cnctd}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{\PYGZhy{}[A\PYGZhy{}Za\PYGZhy{}z0\PYGZhy{}9]+}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Connected}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{matches}\PYG{o}{=}\PYG{n}{re}\PYG{o}{.}\PYG{n}{finditer}\PYG{p}{(}\PYG{n}{regex\PYGZus{}cnctd}\PYG{p}{,} \PYG{n}{Connected}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{re}\PYG{o}{.}\PYG{n}{MULTILINE}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{matchNum}\PYG{p}{,} \PYG{n}{match} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{matches}\PYG{p}{,} \PYG{n}{start}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{Connected}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{match}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}
                        \PYG{k}{break}
        \PYG{k}{return}\PYG{p}{(}\PYG{n}{Connected}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}